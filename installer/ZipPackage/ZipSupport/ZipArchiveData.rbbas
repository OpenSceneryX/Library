#tag ClassProtected Class ZipArchiveData	#tag Method, Flags = &h0		Function cleanName(fileName as String) As String		  // "/" and "\" are illegal chars in DOS file names and Zip archives, so we need to replace them		  dim s as String		  if EmulateOSXRenaming then		    s = ReplaceAll(fileName, "/", ":") // OSX actually allows "\" in its archives		  else		    s = ReplaceAll(ReplaceAll(fileName, "/", "-"), "\", "-")		  end		  return s		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function encodeForZip(name as String) As String		  if name.Encoding = nil then		    name = name.DefineEncoding(Encodings.SystemDefault)		  end		  #if TargetMacOS		    // there is an ugly problem on Mac OS:		    // if we retrieve a filename from a FolderItem, it is Unicode encoded with decomposed characters,		    // but we need them composed in order to be able to convert them to DOSLatinUS (because of an		    // apparently bug in the Mac OS textconverter routines - converting to WinLatin works fine)		    // We work around this problem by converting to WinLatin first in this case		    // ### the better solution would be to use a unicode string composing function for this		    if me.archiveEncoding.Base = 1024 then		      name = name.ConvertEncoding(Encodings.WindowsANSI)		    end		  #endif		  name = name.ConvertEncoding(me.archiveEncoding)		  return name		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor()		  me.dosLatinUS = GetTextEncoding(&H400) // code page 437		  me.filenameEncoding = findFileNameEncoding()		  #if DefaultToUnicode		    setArchiveEncoding Encodings.UTF8 // this is the encoding used by Mac OS X		  #else		    setArchiveEncoding me.dosLatinUS // this is the encoding used originally by most Zip archives (i.e. those made on DOS or Windows)		  #endif		  me.mb4 = NewMemoryBlock(4)		  me.mb4.LittleEndian = false		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function decodeFromZip(name as String) As String		  //### this code is not working well: it should have access to the entry because there it could check the "version made by" value		  // in order to auto-detect the individual encoding. until then, at least the default encoding could be detected for Apple's zip and for ZipIt with unicode support		  return name.DefineEncoding(me.archiveEncoding)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub setArchiveEncoding(enc as TextEncoding)		  #if DebugBuild		    if enc.internetName <> "UTF-8" then		      break // this is just for testing by TT - remove this for production code! ###		    end		  #endif		  		  if enc = nil then		    enc = me.filenameEncoding // use the local encoding		  end		  me.archiveEncoding = enc		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function findFileNameEncoding() As TextEncoding		  // we need to return the encoding that RB uses for		  // file names. On Mac OS, starting with RB 4.5, this		  // is always UTF-8, on Windows it's currently (RB 5.1b3)		  // not Unicode, so we use the the encoding the app uses for text,		  // and hope this will work best (if not, we'd need to convert		  // on a per-case basis in decodeFromZip and encodeForZip)		  		  dim enc as TextEncoding		  		  #if TargetWin32		    enc = Encodings.SystemDefault		  #else		    enc = Encodings.UTF8		  #endif		  		  return enc		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function isFakeEntry(fh as MemoryBlock, localFlags as Integer) As Boolean		  dim fl as Integer		  if BitwiseAnd(fh.UShort(8), 8) <> 0 then		    if localFlags <> -1 then		      fl = localFlags		    else		      me.zipStream.Position = fh.Long(42)+6		      fl = me.zipStream.ReadShort // 00 00   General purpose bit Flag		    end		    return BitwiseAnd(fh.UShort(8),65535-8) = fl		  end		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function getUnixPermissionsFromFile(fsRef as MemoryBlock, ByRef perm as Integer) As Integer		  #if TargetMacOS		    		    Dim pb, info as MemoryBlock, err as Integer		    		    #if TargetCarbon		      Declare Function PBGetCatalogInfoSync Lib CarbonLibName (paramBlock as Ptr) as Short		    #else		      Declare Function PBGetCatalogInfoSync Lib "InterfaceLib" (paramBlock as Ptr) as Short		    #endif		    		    info = NewMemoryBlock(144) // FSCatalogInfo		    		    pb = NewMemoryBlock(72) // FSRefParam		    pb.Ptr(28) = fsRef		    pb.long(32) = &H0400 // FSCatalogInfoBitmap: permissions		    pb.Ptr(36) = info		    		    err = PBGetCatalogInfoSync(pb)		    		    if err = 0 then		      perm = info.UShort(56+8+2)		    else		      perm = 0		    end		    return err		    		  #else		    		    perm = 0		    return -1		    		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function makeFSRef(f as FolderItem) As MemoryBlock		  return FSRefOfFolderItem (f)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function updateUnixPermissions(fsRef as MemoryBlock, perm_and as Integer, perm_or as Integer) As Integer		  #if TargetMacOS		    		    Dim pb, info as MemoryBlock, err as Integer		    		    #if TargetCarbon		      Declare Function PBSetCatalogInfoSync Lib CarbonLibName (paramBlock as Ptr) as Short		      Declare Function PBGetCatalogInfoSync Lib CarbonLibName (paramBlock as Ptr) as Short		    #else		      Declare Function PBSetCatalogInfoSync Lib "InterfaceLib" (paramBlock as Ptr) as Short		      Declare Function PBGetCatalogInfoSync Lib "InterfaceLib" (paramBlock as Ptr) as Short		    #endif		    		    info = NewMemoryBlock(144) // FSCatalogInfo		    		    pb = NewMemoryBlock(72) // FSRefParam		    pb.Ptr(28) = fsRef		    pb.long(32) = &H0400 // FSCatalogInfoBitmap: permissions		    pb.Ptr(36) = info		    		    err = PBGetCatalogInfoSync(pb) // it's a field of 16 bytes, so we need to read them first		    if err = 0 then		      info.UShort(56+8+2) = BitwiseOr(perm_or, BitwiseAnd(perm_and, info.UShort(56+8+2)))		      err = PBSetCatalogInfoSync(pb)		    end		    		    return err		    		  #else		    		    return -1		    		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function shiftRight16(n as Integer) As Integer		  // logical shift right by 16 bits		  me.mb4.Long(0) = n		  return me.mb4.Ushort(0)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function shiftLeft16(n as Integer) As Integer		  // shift left by 16 bits		  me.mb4.Short(0) = n		  me.mb4.Short(2) = 0		  return me.mb4.Long(0)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub checkDirectory(namesDict as Dictionary)		  // Subroutine for z_readDirectory()		  //		  // It checks for the presence of AppleDouble forks stored in Apple's ditto format as used by		  // Mac OS 10.4 Tiger for zip archives created in the Finder		  // If such entries are present, they're removed from the main directory and linked to their "normal" counterpart entries instead		  //		  // Such AppleDouble items are identified as follows		  // - they have the same name as their "normal" counterpart, but with "._" prepended		  // - both the AppleDouble and the "normal" entry use a "Info-Zip Unix" Extra Field (code 0x5855 LE)		  // - the CRC, CompressedSize and UncompressedSize fields in the Local file headers of AD entries are zero! (arghh, idiots!)		  // - items for files may (a) be stored in a parallel directory tree under the root named "__MACOSX", e.g: __MACOSX/f1/._.DS_Store (the Finder does this)		  // - items for files may (b) be stored in the same directory, just with the ".-" prepended (done with command 'ditto -ck')		  // - items for folders may be stored in the same directory, as files (i.e. without the "/"): e.g. folder: "foo/", appledouble file: "._foo"		  		  dim entryIdx, mainIdx, ofs as Integer		  dim ze, zeMain as ZipEntry		  dim s, name as String		  dim isMACOSX as Boolean		  		  for entryIdx = Ubound(me.entries_1) downTo 1 // loop backwards to that we can remove items without trouble		    ze = me.entries_1(entryIdx)		    // check if this entry is a AppleDouble entry in the form of Mac OS X's ditto format		    if ze.ExtraFieldInCentralDir().IsUnixType1Only and ze.z_hasDittoName  then		      name = ze.z_origEncodedName()		      isMACOSX = Left (name, 9) = "__MACOSX/"		      if isMACOSX then		        name = Mid (name, 10) // cut off the "__MACOSX/" from the name		      end		      if isMACOSX and (Len(name) = 0 or Right(name, 1) = "/") then		        // it's just a folder inside the MACOSX tree - remove it entirely		        me.entries_1.Remove entryIdx		      else		        // find and remove the "._" from the file name		        ofs = me.lastInStr("/"+name, "/._")		        if ofs <= 0 then		          'beep // oops - this is weird, because ze.z_hasDittoName has already seen the "._"		        else		          s = name		          name = Left (name, ofs-1) + Mid (name, ofs+2)		          name = EncodeBase64(name)		          if not namesDict.HasKey(name) then		            'beep // no counterpart? this is odd		          else		            zeMain = namesDict.Value(name)		            namesDict.Remove(name)		            // link the appledouble entry to its main counterpart		            me.entries_1.Remove entryIdx		            zeMain.z_setAppleDoubleEntry (ze)		            me.dittoFormat = true		          end		        end		      end		    end		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function lastInStr(source as String, target as String) As Integer		  // returns index of last occurance of target in source, or 0 if not found		  dim lastOfs, newOfs as Integer		  newOfs = InStr(source, target)		  if newOfs <= 0 then		    return 0		  end		  do		    lastOfs = newOfs		    newOfs = InStr(lastOfs+1, source, target)		  loop until newOfs <= 0		  return lastOfs		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function lookup(encPath as String, startIdx as Integer) As Integer		  dim idx, lastIdx as Integer		  lastIdx = Ubound(me.entries_1)		  for idx = startIdx to lastIdx		    if encPath = me.entries_1(idx).z_origEncodedName then		      return idx		    end		  next		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function FSSpecOfFSRef(fsRef as MemoryBlock) As MemoryBlock		  #if TargetMacOS		    dim spec as new MemoryBlock(70)		    if spec = nil then		      raise new OutOfMemoryException		    end		    Declare function FSGetCatalogInfo Lib CarbonLibName (fsRef as Ptr, which as Integer, catInfo as Integer, outName as Integer, fsSpec as Ptr, parentRef as Integer) as Short		    if 0 = FSGetCatalogInfo (fsRef, 0, 0, 0, spec, 0) then		      return spec		    end		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function FSRefOfFolderItem(f as FolderItem) As MemoryBlock		  // returns NIL if the FolderItem does not exist		  		  #if TargetMacOS		    #if TargetMachO		      dim ref as new MemoryBlock(80)		      if ref = nil then		        raise new OutOfMemoryException		      end		      Declare function REALFSRefFromFolderItem Lib "" (f as FolderItem, FSRef as Ptr, HFSUniStr255 as Ptr) as Boolean		      if REALFSRefFromFolderItem (f, ref, nil) then		        return ref		      end		    #else		      declare Function FSpMakeFSRef Lib CarbonLibName (source as Ptr, newRef as Ptr) as Short		      dim spec, ref as MemoryBlock, err as Integer		      spec = NewMemoryBlock(70)		      ref = NewMemoryBlock(80)		      if ref = nil or spec = nil then		        raise new OutOfMemoryException		      end		      spec = FSSpecOfFolderItem (f)		      err = FSpMakeFSRef(spec, ref)		      if err = 0 then		        return ref		      end		    #endif		  #endif		  		  // this code would create a FSRef from a parent dir ref and file name therein:		  'Declare function FSMakeFSRefUnicode Lib CarbonLibName (parentFSRef as Ptr, nameLength as Integer, uniCharPtr as Integer, textEncodingHint as Integer, outFSRef as Ptr) as Short		  'dim err as Integer		  'dim namePtr as new MemoryBlock(4)		  'namePtr.Ptr(0) = uniName		  'dim newRef as new MemoryBlock(80)		  'err = FSMakeFSRefUnicode (parentRef, uniName.Short(0), namePtr.Long(0)+2, &HFFFF, newRef)		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function FSSpecOfFolderItem(f as FolderItem) As MemoryBlock		  #if TargetMacOS		    dim spec as new MemoryBlock(70)		    if spec = nil then		      raise new OutOfMemoryException		    end		    #if UseTTsOldPlugins		      spec.FSSpec(0) = f // uses TT's MemoryBlock Plugin (see <http://www.tempel.org/rb/>)		    #else		      // This uses a "hack" to access a public RB Plugin API function.		      // While this access procedure not officially sanctioned by RS, it works for now		      Declare function REALFSSpecFromFolderItem Lib "" (spec as Ptr, f as FolderItem) as Boolean		      if REALFSSpecFromFolderItem (spec, f) then		        return spec		      end		    #endif		  #endif		End Function	#tag EndMethod	#tag Note, Name = About				This module is a support class for "ZipArchive"		Its properties are NOT meant to be user-accessible.				Background:				Instead of storing some information directly in properties		of the ZipArchive class, they are stored here to avoid a		circular reference to ZipArchive which would cause a		leak if a using program would not call ZipArchive.Close		and then lose the object reference to the archive class.				This class also contains a few methods that the other		classes may need.	#tag EndNote	#tag Property, Flags = &h0		dirty As Boolean	#tag EndProperty	#tag Property, Flags = &h0		monitor As ZipProgressNotifier	#tag EndProperty	#tag Property, Flags = &h0		entries_1(0) As ZipEntry	#tag EndProperty	#tag Property, Flags = &h0		theFile As FolderItem	#tag EndProperty	#tag Property, Flags = &h0		zipStream As BinaryStream	#tag EndProperty	#tag Property, Flags = &h0		copyChunkSize As Integer	#tag EndProperty	#tag Property, Flags = &h1		Protected archiveEncoding As TextEncoding	#tag EndProperty	#tag Property, Flags = &h1		Protected filenameEncoding As TextEncoding	#tag EndProperty	#tag Property, Flags = &h1		Protected dosLatinUS As TextEncoding	#tag EndProperty	#tag Property, Flags = &h0		defaultOSMadeBy As Integer	#tag EndProperty	#tag Property, Flags = &h0		addUnixPerm As Boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected mb4 As MemoryBlock	#tag EndProperty	#tag Property, Flags = &h0		dittoFormat As Boolean	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="dirty"			Group="Behavior"			InitialValue="0"			Type="Boolean"		#tag EndViewProperty		#tag ViewProperty			Name="copyChunkSize"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="defaultOSMadeBy"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="addUnixPerm"			Group="Behavior"			InitialValue="0"			Type="Boolean"		#tag EndViewProperty		#tag ViewProperty			Name="dittoFormat"			Group="Behavior"			InitialValue="0"			Type="Boolean"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass