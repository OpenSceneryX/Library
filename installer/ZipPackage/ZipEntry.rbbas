#tag ClassProtected Class ZipEntry	#tag Method, Flags = &h0		Sub ApplyMacBinaryInformation(f as FolderItem, mbHdr as MemoryBlock)		  // You may use this function after calling Extract(outputStream as BinaryStream)		  //   in order to update your extracted file's Type, Creator and other Finder information.		  //  This call has even a little effect under Windows OS: If the MacBinary header		  //   specifies that the item was invisible (hidden), or read-only, these attributes		  //   will be applied under Windows to the file, too.		  //		  // Parameters:		  //   f: the file or folder you want the MB information applied to		  //   mbHdr: the MacBinary header. Retrieve it by calling GetMacBinaryHeader(mbHdr)		  //		  // Preconditions:		  // - f.Exists = true		  // - mbHdr <> nil		  		  dim spec, pb as MemoryBlock, res as Integer		  dim date1, date2 as Date		  		  if not f.Exists or mbHdr = nil then		    return		  end		  		  mbHdr.LittleEndian = false		  		  // !TT 21Jun05 - Fixed setting of creation date. For some strange reason one cannot modify the TotalSeconds property of f.CreationDate directly but must use an interim Date object for this		  if mbHdr.Long(95) <> 0 then		    date1 = new Date		    date2 = new Date		    date1.TotalSeconds = z_ulongToDouble(mbHdr.Long(91)) // creation date		    date2.TotalSeconds = z_ulongToDouble(mbHdr.Long(95)) // modification date		    f.CreationDate = date1		    f.ModificationDate = date2		  end		  		  z_adjustMacFilename mbHdr.PString(1), mbHdr.Byte(106), f		  		  #if TargetMacOS		    		    if not f.Directory and mbHdr.UInt64Value(65) <> 0 then		      f.MacType = mbHdr.StringValue(65,4)		      f.MacCreator = mbHdr.StringValue(69,4)		    end		    		    ///////////////////////////		    // apply FInfo + FXInfo		    		    #if TargetMachO and AvoidFSSpecCalls		      Declare Function PBGetCatalogInfoSync Lib CarbonLibName (FSRefParam as Ptr) as Integer		      Declare Function PBSetCatalogInfoSync Lib CarbonLibName (FSRefParam as Ptr) as Integer		      ... still missing ###		    #else		      Declare Function PBGetCatInfoSync Lib CarbonLibName (paramBlock as Ptr) as Integer		      Declare Function PBSetCatInfoSync Lib CarbonLibName (paramBlock as Ptr) as Integer		      spec = ZipFolderItem.FSSpecOfFolderItem (f)		      pb = NewMemoryBlock(108)		      if pb = nil then		        raise new OutOfMemoryException		      end		      pb.Ptr(18) = spec		      pb.Long(18) = pb.Long(18) + 6		      pb.Short(22) = spec.Short(0)		      pb.Long(48) = spec.Long(2)		      res = PBGetCatInfoSync(pb)		      if res <> 0 then		        break		      else		        dim v as Integer		        v = BitwiseAnd(&HFF-&H11,mbHdr.Byte(73)) // FInfo.fdFlags (hi), but clear "hasBeenInited" and "nameLocked" flags		        v = Bitwise.ShiftLeft (v, 8) + mbHdr.Byte(101) // FInfo.fdFlags (lo)		        pb.UShort(32+8) = v // this is PPC- and Intel-savvy		        pb.UShort(84+8) = mbHdr.UShort(106) // FXInfo.fdScript, fdXFlags		        pb.Long(48) = spec.Long(2)		        res = PBSetCatInfoSync(pb)		      end		    #endif		    		    //		    ///////////////////////////		    		  #else		    		    f.Visible = BitwiseAnd(mbHdr.Byte(73),&H40) = 0		    		  #endif		  		  if me.lockFiles and mbHdr.Byte(81) <> 0 and not f.Directory then		    f.Locked = true //Note: this one must come last, or changes to other properties may not work		  end		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function CanExtract() As Boolean		  dim i as Integer		  i = CompressionMethod()		  return (i = 0 or i = 8) and not IsEncrypted() and not IsDirectory()		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Comment() As String		  // Returns the optional comment about the entry. Returns empty string if no comment available		  		  return me.sysEncComment		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CompressedSize() As UInt32		  return me.header.UInt32Value(20)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CompressionMethod() As Integer		  // common values:		  // 0: stored (not compressed - can always be read)		  // 1: shrunk (not supported)		  // 6: imploded (not supported)		  // 8: deflated (supported through e-CryptIt Engine plugin)		  		  return me.header.UShort(10)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(archiveData as ZipArchiveData, hdr as MemoryBlock, origEncName as String, extra as ZipExtraField, origEncComment as String)		  // private constructor, to be used only by ZipArchive.readEntries		  		  me.d = archiveData		  		  me.header = hdr		  me.extra = extra		  me.zipEncName = origEncName		  me.zipEncComment = origEncComment		  		  me.sysEncName = me.d.decodeFromZip(me.zipEncName)		  me.sysEncComment = me.d.decodeFromZip(me.zipEncComment)		  		  if me.extra = nil then		    // me.extra must not be nil any more (since v1.1)		    me.extra = new ZipExtraField(me.d, "")		    me.extra.Lock		  end		  		  z_checkRawPath		  z_setup		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub EnableFileLocking(enabled as Boolean)		  // Since v1.1 of this Zip package, items marked as "protected" in the archive		  // will not be locked any more by default when extracted.		  // To have such items locked at extraction, call this function with "true" as		  // the "enabled" parameter.		  		  me.lockFiles = enabled		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub EnableMacBinary1Detection(enabled as Boolean)		  // By default, the outdated "MacBinary I" format will not be detected. Some zip and MB encoding		  // tools on other platforms may create incorrect or those outdated MB-headers.		  // If you enabable this mode, they're more likely to be detected as being MB-headers.		  // This feature comes with a risk, however: Normal files, that are not MB-encoded, might		  // mistakenly believed to be MB-encoded, in seldom cases. For that reason, enable this		  // feature only in cases where you believe you need it, but not be default!		  //		  // To use this feature, you must call this function before you attempt to extract the item.		  // To be more safe, you should only enable this feature if the item's file name ends with		  // ".bin", since this is usually the case for MB encoded files of this problematic kind.		  		  me.supportMB1 = enabled		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function ErrorMessage() As String		  // Returns a desciption about the latest error as an english phrase		  //		  // Functions calls that could cause such an error:		  // - Extract()		  // - Verify()		  // - SetPath() (the one returning a Boolean result)		  // - ExtraField()		  		  return me.errmsg		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ExternalFileAttributes() As Integer		  // retrieves "external file attributes", a 4 byte field		  //		  // On Unix, this field contains the permissions in the upper 8 bits; on DOS/Windows, the lowest		  // byte contains the File Attribues (read only, hidden, system, volume label, etc.)		  //		  // Call SetExternalFileAttributes() to change the value.		  //		  // Default for newly created items depends on "OSMadeBy" for the item:		  //  if 3 (unix), the file's permissions are copied, provided this code runs on a Mac or Linux machine (but not Windows),		  //  otherwise this field is set to 0.		  // However, the lowest byte (bit 0) can contain the value 1 to tell ZipIt 2.2.2 that the file name is UTF-8 encoded		  		  return me.header.Long(38)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Extract(decodeMacBinary as Boolean, dataOut as SeqDataOutputStream, rsrcOut as SeqDataOutputStream, ByRef mbHdr as MemoryBlock) As Boolean		  // Writes the data of this entry to one or two streams.		  // If decodeMacBinary is FALSE or if the data is not MacBinary encoded, then all data is written to the		  //   dataOut stream, and rsrcOut is not used.		  // If decodeMacBinary is TRUE and if the data is MacBinary encoded, the two forks are streamed to dataOut		  //   and rsrcOut, respectively. If either of the two stream parameters is nil, their fork will be skipped;		  //   mbHdr will be set to a MemoryBlock of size 128 containing the MacBinary header. This works even		  //   on folders which have a MacBinary header.		  // The streams will be opened and closed by this function as needed.		  // Returns TRUE if the extraction was successful. FALSE might mean a bad CRC or other data or writing errors.		  		  dim mb as MemoryBlock, ok as Boolean		  		  mbHdr = nil		  		  if dataOut = nil and rsrcOut = nil and decodeMacBinary = false then		    // this makes no sense -> alert the programmer		    raise new RuntimeException		  end		  		  dim aborted as Boolean		  ok = z_unzip(dataOut, rsrcOut, decodeMacBinary, me.isFolder, mb, false, aborted)		  		  mbHdr = mb		  		  return ok		  		exception err as RuntimeException		  me.errmsg = "Internal error (exception)"		  return false		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Extract(destination as FolderItem) As Boolean		  // Same as Extract(destination as FolderItem, decodeMacBinary as Boolean),		  //   but with the difference that decodeMacBinary is always TRUE, which		  //   leads to properly extracted files on Mac OS system, and will extract		  //   the data fork only of files in MacBinary format on Windows systems,		  //   meaning that the (on Windows useless) Resource fork will be discarded		  //   on Windows systems, which is usually what people want.		  		  return Extract (destination, true, true, false, false)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Extract(fdest as FolderItem, decodeMacBinary as Boolean, makeExecutable as Boolean, keepBadFiles as Boolean, ignoreBadMacMetadata as Boolean) As Boolean		  // Stores the data of this entry in a file or creates a folder.		  // If the destination item already exists, it will be replaced, unless there's a folder<->file conflict		  //   or if the file, containing folder or volume is write protected (locked)		  // Sets the modification (but not creation) date to the information from the archive entry.		  // If the entry contains Type&Creator information, the destination file will get them assigned,		  //   otherwise T&C will be set depending on the file's extension. (Mac OS only)		  // If the entry contains an explicit Macintosh file name, the destination will receive this name		  //   if the passed destination.Name was identical to the archive entry's DOS name. (Mac OS only)		  // If the entry is stored in MacBinary format and decodeMacBinary is TRUE, it will be automatically		  //   split into its data and resource fork - on Mac OS both will be written to the destination file,		  //   on Windows only the data fork will be written, while the resource fork will be ignored.		  // If 'makeExecutable' is true, extracted files that are not marked as text files and which do not		  //   contain unix file permissions, will be made executable on Mac OS systems so that Mac OS		  //   Packages become executable (Stuffit Expander does this, too). If this parameter is false,		  //   files will be made executable only if unix permissions are included (this is how the unix		  //   command line tools "zip" and "unzip" do it). Using "false" may speed up extraction a little,		  //   that's why you have the choice here: if you know that the archive you are extracting has been		  //   created with this software (v1.2) or the cmdline "zip" tool, the correct permissions will 		  //   automatically be set, then set 'makeExecutable' to "false"; but if the file may contain executable		  //   files and has been created by some other tools such as ZipIt, you might want to set this parm		  //   to true to make sure the files remain executable after extraction.		  // Returns TRUE if it was successful. FALSE might mean a bad CRC or other data errors,		  //   including a write failure due to a locked or full volume or existing and locked file		  		  dim dataFork, rsrcFork as SeqDataOutputStream, d as Date, ok as Boolean, type, crea, name as String		  dim fsref, mbHdr as MemoryBlock, bs as BinaryStream		  dim zdest as ZipFolderItem		  		  if fdest = nil and not keepBadFiles then		    me.errmsg = "No destination given"		    return false		  end		  		  dim attr as Integer = me.ExternalFileAttributes // The low byte usually contains the DOS File Attribute, the high word the permissions		  dim st_mode as UInt16 = Bitwise.ShiftRight(attr, 16)		  dim isSymlink as Boolean = Bitwise.BitAnd(st_mode,&o170000) = &o120000		  		  if fdest <> nil then		    		    zdest = new ZipFolderItem(fdest)		    		    if me.isFolder then		      		      //		      // we extract a folder		      //		      if not zdest.exists then		        zdest.CreateAsFolder		      end		      if not zdest.exists then		        me.errmsg = "Folder creation failed"		        return false		      end		      if not zdest.Directory then		        break		        me.errmsg = "Archive entry is a folder but a file exists at the destination already. Won't replace that."		        return false		      end		      		    else		      		      //		      // we extract a file		      //		      		      if zdest.Directory then		        break		        me.errmsg = "Archive entry is a file but a folder exists at the destination already. Won't replace that."		        return false		      end		      		      zdest.Delete // delete the existing regular file or symlink or alias		      if zdest.Exists then		        break		        me.errmsg = "A file exists already at the destination which can't be deleted"		        return false		      end		      		      if isSymlink then		        // We need to create a symlink here		        dataFork = new StringWriter()		      else		        // we write a regular file		        bs = zdest.CreateBinaryFile("")		        if bs = nil then		          me.errmsg = "Creating destination file failed"		          return false		        end		        bs.Close		        		        #if TargetMacOS		          // new files default to "????" - let's change them to zeros		          type = new MemoryBlock(4)		          zdest.MacCreator = type		          zdest.MacType = type		        #endif		        		        // create a data fork writer		        dataFork = new FileWriter(zdest)		        		        // create a rsrc fork writer in case we're on the Mac and it shall be extracted from the entry data		        #if TargetMacOS		          if decodeMacBinary then		            rsrcFork = new RsrcForkWriter(zdest)		          end		        #endif		      end		      		    end if ' me.isFolder else		  end if ' fdest <> nil		  		  // perform the extraction		  dim aborted as Boolean		  ok = z_unzip(dataFork, rsrcFork, decodeMacBinary, me.isFolder, mbHdr, ignoreBadMacMetadata, aborted)		  		  if zdest <> nil then		    		    if not ok and (aborted or not keepBadFiles) then		      		      zdest.Delete		      		    else		      		      if isSymlink then		        zdest.CreateSymlink (StringWriter(dataFork).WrittenData)		      end		      		      // update modification time/date		      d = me.Time()		      if d <> nil then		        zdest.CreationDate = d // !TT 21Jun05 added to prevent Norton and other tools from complaining about creation > modification date		        zdest.ModificationDate = d		      end		      		      #if TargetMacOS		        // update Type and Creator		        // Note: if type is set to "slnk" (creator to "rhap"), the file becomes a Symlink		        if isSymlink then		          // no messing with symlinks!		        elseif mbHdr <> nil then		          // use the Type and Creator from the stored file's MacBinary header		          ApplyMacBinaryInformation(zdest, mbHdr)		        elseif me.extra <> nil and me.extra.GetTypeCreatorName(type, crea, name) then		          // use the information from the archive entry's Extra Field		          zdest.MacType = type		          zdest.MacCreator = crea		          if name <> "" then		            z_adjustMacFilename name, 0, zdest		          end		        end		      #endif		      		      dim os as Integer = me.OSMadeBy		      dim isWinOrUnix as Boolean = (os = 0 or os = 3 or os = 11) // 0 -> PKZip, 3 -> Info-Zip, 7 -> ZipIt, 11 -> NTFS (Info-Zip for NT)		      		      // update Unix permissions		      if isWinOrUnix and (Bitwise.BitAnd (attr, 2) <> 0) then // DOS hidden attribute		        zdest.Visible = false		      end		      if Bitwise.BitAnd (st_mode,&o7777) <> 0 and (isWinOrUnix or os = 7) then		        // attributes field appears to contain unix permissions		        zdest.SetUnixPermissions (st_mode)		      elseif makeExecutable and not me.isFolder and not me.IsTextFile() then		        // set the "executable" permission on all binary files to make apps runnable that are Mac OS Packages		        zdest.SetUnixPermissions (Bitwise.BitOr (zdest.UnixPermissions, &o111))		      end		      		    end		    		  end		  		  return ok		  		Exception err as RuntimeException		  me.errmsg = "Internal error (exception)"		  return false		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ExtraField() As ZipExtraField		  // Returns the Extra Field from the Local Header, which may be different from the one in		  // the Central Directory Header -- If they differ, this one is always the one with all the infos,		  // while the other one may leave out some information (see the Zip Archive specs).		  // Accessing this one is a bit slower, however, since it must still be read from the archive,		  // while the Extra Field in the Local Header is already cached in memory.		  //		  // If an error occured, nil will be returned, otherwise a valid object is returned, even if the Extra Field is empty		  		  dim lastpos, NameLen, ExtraFieldLen, i as Integer		  dim zipStream as BinaryStream		  dim extra as ZipExtraField		  		  zipStream = me.d.zipStream		  		  if zipStream = nil then		    me.errmsg = "Archive is closed"		    return nil		  end		  		  lastpos = zipStream.Position		  zipStream.Position = me.header.UInt32Value(42)		  		  i = zipStream.ReadLong // 50 4B 03 04   File Header Signature		  if i <> &h04034B50 then		    zipStream.Position = lastpos		    me.errmsg = "Invalid Local File Header signature (archive appears to be severely corrupted)"		    return nil		  end		  		  zipStream.Position = zipStream.Position+22		  		  NameLen = zipStream.ReadShort // Filename Length		  ExtraFieldLen =  zipStream.ReadShort // Extra Field Length		  zipStream.Position = zipStream.Position + NameLen		  		  extra = new ZipExtraField(me.d, zipStream.Read(ExtraFieldLen))		  extra.Lock		  		  zipStream.Position = lastpos		  		  return extra		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ExtraFieldInCentralDir() As ZipExtraField		  // Returns the Extra Field from the Central Directory Header, which may be different from		  // the one in the Local Header -- If they differ, this one may leave out some information,		  // while the other one contains all the infos (see the Zip Archive specs).		  // Accessing this one is faster, however, since it's already cached in memory, while		  // the Extra Field in the Local Header must still be read from the archive.		  		  if not me.extra.IsLocked then		    // this would be an internal error - this obj must have been locked when it was passed to ZipEntry		    raise new RuntimeException		  end		  		  return me.extra // must not be nil any more (since v1.1)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetMacBinaryHeader(ByRef mbHdr as MemoryBlock) As Boolean		  // Returns TRUE if the item is stored in MacBinary format. Will		  //   also return the 128 Byte long MacBinary header in this case.		  // Returns FALSE otherwise, along with setting "mbHdr" to nil.		  //		  // The Type and Creator can be retrieved as follows:		  //   MacType = mbHdr.StringValue(65,4)		  //   MacCreator = mbHdr.StringValue(69,4)		  //   DataForkSize = mbHdr.Long(83)		  //   RsrcForkSize = mbHdr.Long(87)		  //		  // You may also call ApplyMacBinaryInformation() to apply Type, Creator and		  //   other file/folder attributes from the MacBinary header to a file or folder.		  //		  // For more information on the MacBinary format, see:		  //   http://www.lazerware.com/formats/		  		  dim mb as MemoryBlock		  		  mbHdr = nil		  		  dim aborted as Boolean		  if not z_unzip(nil, nil, true, true, mb, false, aborted) then		    return false		  end		  		  me.errmsg = ""		  mbHdr = mb		  return mbHdr <> nil		  		Exception err as RuntimeException		  me.errmsg = "Internal error (exception)"		  return false		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub GetPath(names() as String)		  // returns the file name and path in an array split by the directory separators		  		  dim i as Integer		  		  redim names(Ubound(me.path))		  for i = 0 to Ubound(me.path)		    names(i) = me.path(i)		  next		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function IsDirectory() As Boolean		  return me.isFolder		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function IsEncrypted() As Boolean		  return BitwiseAnd(me.header.UShort(8),1) <> 0		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function IsTextFile() As Boolean		  // This information is currently (24Apr03) not used inside the Zip package.		  // That means: if a text file is extracted, no changes to the end-of-line chars		  // will be made.		  		  return BitwiseAnd(me.header.UShort(36),1) <> 0		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function MakeDestination(root as FolderItem, followAliases as Boolean) As FolderItem		  // Creates a FolderItem object for the original path given by the archive entry.		  // Will create intermittent folders if necessary.		  //		  // Caution: "nil" may be returned if followAliases=false and an Alias exists at that place already,		  // or when a file exists where a folder is desired by the destination path		  		  dim dest as FolderItem, i as Integer		  dest = root		  for i = 0 to Ubound(me.path)		    dest = MakeDestinationChild(dest, me.path(i), followAliases)		  next		  return dest		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function MakeDestinationChild(dir as FolderItem, pathItem as String, followAliases as Boolean) As FolderItem		  dim dest as FolderItem, s as String		  dest = dir		  s = me.d.decodeFromZip(me.d.encodeForZip(pathItem))		  if s = ".." then		    dest = dest.Parent		  elseif s <> "" then		    if not dest.exists then		      dest.CreateAsFolder		    end		    if followAliases then		      dest = dest.Child(s)		    else		      dest = dest.TrueChild(s)		    end		  end		  return dest  		Exception exc as RuntimeException		  return nil		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Name() As String		  // returns the file name without any path in front of it		  		  return me.path(Ubound(me.path))		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function OSMadeBy() As Integer		  // Read: "OS made by"		  //		  // Returns the code of the OS that this entry is using for file name encoding and		  // text file end-of-line format.		  // See the "PKZIP format.txt" or any "appnote.txt" on the web for the codes		  //		  // Call SetOSMadeBy() to change the value. Default for newly created items is 0		  // (This default can be changed using ZipArchive.SetDefaultOSMadeBy)		  		  return me.header.Byte(5)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function RawPath() As String		  // Returns the path as it appears in the Zipfile's directory.		  //		  // It always uses "/" as directory separators, even on Mac OS Classic!		  //		  // So be careful: This name may not be the original file's path, because		  //   if the original name contained invalid DOS chars, such as "/",		  //   then this returns a cleaned up name!		  		  return me.sysEncName		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function SameRawPath(rawPath as String) As Boolean		  // Use this function if you want to see if a given path is equal to		  // the one of this entry. Do not get the path using RawPath()		  // and then compare yourself, because that might fail with		  // non-ASCII characters in file names that are unicode encoded		  // (this is because there are several different ways to encode		  // the same non-ASCII character, and it happens under Mac OS		  // that exactly this will happen: "ä" <> "ä"). This function takes		  // care of this problem.		  		  return me.d.encodeForZip(rawPath) = me.zipEncName		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub SetComment(comment as String)		  // Sets the entry's comment that'll be stored in the archive		  // when the directory is written (by ZipArchive.Close or		  // ZipArchive.Flush)		  		  me.sysEncComment = comment		  		  me.zipEncComment = me.d.encodeForZip(me.sysEncComment)		  me.d.dirty = true		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetExternalFileAttributes(attr as Integer)		  // Sets the 4-byte Attributes field		  //		  // On Unix, this field contains the permissions in the upper 8 bits; on DOS/Windows, the lowest		  // byte contains the File Attribues (read only, hidden, system, volume label, etc.)		  //		  // Call ExternalFileAttributes() to inquire about the current value		  		  me.header.Long(38) = attr		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetExtraFieldInCentralDir(extraField as ZipExtraField)		  // Sets a new Extra Field for the Central Directory only. Use this function		  // if you want to add an Extra Field that differs between the two Headers.		  // To achieve this, first create the "long" Extra Field and provide it when		  // you add the file to the archive. After that, call this function to set		  // the Extra Field in the Central Dir Header.		  		  dim ef as ZipExtraField		  		  ef = extraField		  if ef = nil then		    ef = new ZipExtraField(me.d, "")		  end		  ef.Lock		  me.extra = ef		  me.header.UShort(30) = LenB(ef.AsData())		  me.d.dirty = true		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetOSMadeBy(code as Integer)		  // See the "PKZIP format.txt" or any "appnote.txt" on the web for the codes		  //		  // Call OSMadeBy() to inquire about the current value		  		  me.header.Byte(5) = code		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetTextFileFlag(isText as Boolean)		  // If you set the "text file" flag, note that the text should use CR+LF end-of-line (EOL)		  // delimiters because the items are marked to be in MS-DOS format, where these		  // EOLs are used for text files. Otherwise, tools that extract such items might not be		  // able to  convert the line endings properly.		  		  if isText then		    me.header.UShort(36) = BitwiseOr(me.header.UShort(36), 1)		  else		    me.header.UShort(36) = BitwiseAnd(me.header.UShort(36), 65535-1)		  end		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function Size() As UInt32		  return me.header.UInt32Value(24)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Time() As Date		  // Returns the time stamp of the entry,		  //   returns nil if the time was not specified in the archive		  		  dim d as Date, tim, dat as Integer		  		  tim = me.header.UShort(12)		  dat = me.header.UShort(14)		  		  if tim = 0 and dat = 0 then		    return nil		  end		  		  d = new Date		  		  // convert date/time from DOS format		  d.Year = BitwiseAnd(dat,&H0FE00) \ &H0200 +1980		  d.Month =  BitwiseAnd(dat,&H1E0) \ &H20		  d.Day = BitwiseAnd(dat,31)		  d.Hour = BitwiseAnd(tim,&HF800) \ &H800		  d.Minute = BitwiseAnd(tim,&H7E0) \ &H20		  d.Second = 2 * BitwiseAnd(tim,&H1F)		  		  return d		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function UTCOffsetInMinutes() As Integer		  // Returns the offset of the current time to UTC (GMT) in minutes.		  // supports Mac OS, Windows and Linux		  //		  // Note that the offset is not always an even multiple of 60,  but		  // there are also half hour offsets, even one 5:45h offset		  		  // This 6th version by Thomas Tempelmann (rb@tempel.org) on 13 Feb 2008		  //  (13 Feb 2008: Linux fix by Ed Lazor)		  //		  // Using code from various authors found on the RB NUG mailing list		  //		  // Latest version can be found here: http://www.tempel.org/rb/#gmt		  		  dim offset as integer		  		  #if TargetLinux or TargetMachO then		    #if TargetMachO then		      declare function localtime_r lib "/usr/lib/libc.dylib" (time_in as Ptr, time_out as Ptr) as Ptr		      declare function time lib "/usr/lib/libc.dylib" (tloc_ptr as Integer) as Integer		    #else		      // 13 Feb 2008: as suggested by Ed Lazor, now we use a "soft" declare and simplify the lib name:		      Soft Declare Function localtime_r Lib "libc" (time_in as Ptr, time_out as Ptr) as Ptr		      Soft Declare Function time Lib "libc" (tloc_ptr as Integer) as Integer		    #endif		    dim time_in, time_out as MemoryBlock		    time_in =  new MemoryBlock(4)		    time_out =  new MemoryBlock(44) // we assume that "int" is 4 byte on any supported Linux system		    time_in.Long(0) = time (0) // Bugfix TT 21Apr06: need to pass current local time to get summer time offsets correctly		    if not TargetLinux or System.IsFunctionAvailable("localtime_r" , "libc") then		      call localtime_r (time_in, time_out)		    end		    offset = time_out.Long (36) \ 60		  #elseif TargetMacOS then		    Declare Sub ReadLocation lib CarbonLibName (location As ptr)		    dim info as memoryBlock		    dim byteOffset as integer		    info = NewMemoryBlock(12)		    ReadLocation info		    if info.LittleEndian then		      byteOffset = 8		    else		      byteOffset = 11		    end		    offset = info.short(9) * 256 + info.byte(byteOffset)		    offset = offset \ 60		  #elseif TargetWin32 then		    Declare Function GetTimeZoneInformation Lib "Kernel32" ( tzInfoPointer as Ptr ) as Integer		    // returns one of		    // TIME_ZONE_ID_UNKNOWN 0		    //      -- Note: e.g. New Delhi (GMT+5:30) and Newfoundland (-3:30) return this value 0		    // TIME_ZONE_ID_STANDARD 1		    // TIME_ZONE_ID_DAYLIGHT 2		    dim info as memoryBlock		    dim result, bias, dayLightbias as integer		    info = new MemoryBlock(172)		    result = GetTimeZoneInformation(info)		    bias = info.Long(0)		    // note about bias: the original code I found in the NUG archives used Long(84) and switched to Long(0)		    // only for result=1 and result=2, but my tests found that Long(0) is also the right value for result=0		    if result = 2 then		      daylightBias = info.long(168)		    end if		    offset = - (bias + dayLightbias)		  #else		    this target is not supported yet - see if there's a new version at <www.tempel.org/rb/>		  #endif		  		  return offset		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Verify() As Boolean		  // Checks the integrity of the data by uncompressing it and verifying its CRC		  // Returns TRUE if data is valid.		  		  dim mb as MemoryBlock		  dim aborted as Boolean		  		  return z_unzip(nil, nil, false, false, mb, false, aborted)		  		exception err as RuntimeException		  me.errmsg = "Internal error (exception)"		  return false		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub z_adjustMacFilename(macName as String, script as Integer, f as FolderItem)		  // Re-apply the file name from the MB header		  // This is useful in cases where the name in the zip directory was converted to match DOS requirements (e.g. no "/" in name)		  		  #if TargetMacOS		    		    Declare Function GetScriptManagerVariable Lib CarbonLibName (selector as Integer) as Integer		    		    //		    // This is difficult, however, since there are two scenarios which compete with each other:		    // 1. The original file had invalid DOS chars, e.g. "name/name". The file name at this point is "name-name", but we want to restore the orig name		    // 2. The original name had > 31 chars, which is stored inside the dir, but the MacBinary info stored a shortened name such as "...#12345.txt"		    //     In this second case, we do not want to restore the name		    // The complicated part is that both cases can be combined: A long name with "/" in it. That one can't possibly be restored.		    //		    // Since long names are usually only created on systems other than Mac OS Classic, i.e. Mac OS X or Windows, where the "/" is not		    // allowed in file names, it's rather unlikely to run into this problem of a long name with "/" - and if, we'll just leave it with the		    // modified long name (without the "/" in it).		    //		    // What remains is to detect whether case 1 or case 2 applies, and only make the modification in case 1		    // We do that by looking at the MacBinary name and converting that into a DOS-valid name. If that name		    // matches the name from the zip directory, then we have case 1 and rename the file		    		    dim te as TextEncoding		    		    if BitwiseAnd(script,&H80) = 0 then		      te = GetFontTextEncoding("System")		    else		      te = GetTextEncoding(BitwiseAnd(script,&H7F))		    end		    if te <> nil then		      macName = macName.DefineEncoding(te)		      if macName <> "" and f.Name <> macName then		        if f.Name = me.d.cleanName(macName) then		          // we have case 1		          if f.Name = me.path(Ubound(me.path)) then // make sure the actual file name matches the one from the zip file's directory		            f.Name = macName		          end		        end		      end		    end		    		  #endif		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub z_checkRawPath()		  dim ch, s as String, i, len as Integer		  		  //		  // extract folders from the full file name		  //		  redim me.path(-1)		  me.isFolder = false		  len = LenB(me.sysEncName)		  for i = 1 to len		    ch = MidB(me.sysEncName, i, 1)		    if ch = "/" then		      if i = len then		        // it's a just folder, not a file (its size may still be non-zero, that happens if the folder contains MacBinary information)		        me.isFolder = true		      end		      if s = "." then		        // ignore		      else		        me.path.append s		      end		      s = ""		    else		      if ch = ":" then		        // ":" is an illegal char in Mac OS file names, so we need to replace it with something else		        if EmulateOSXRenaming and TargetMacOS then		          ch = "/" // this is what Mac OS X's zip does		        else		          ch = "-" // this is what MacZipIt does		        end		      end		      s = s + ch		    end		  next		  if s <> "" then		    me.path.append s		  end		  		  if Left (s, 2) = "._" then		    me.z_hasDittoName = true		  elseif Ubound(me.path) >= 0 and StrComp ("__MACOSX", me.path(0), 0) = 0 then		    me.z_hasDittoName = true		  end		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function z_CRC(mb as MemoryBlock, size as Integer) As Integer		  dim c as Integer		  		  #if HaveEinhugurPlugin		    // using the "e-CryptIt Engine" plugin, see <http://www.einhugur.com/>:		    c = Crc16_MemoryBlock(mb, 0, size, 0)		  #else		    return clsCRC16.CCITT(mb, 0, size)		  #endif		  		  if c < 0 then		    c = c + 65536		  end		  		  return c		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function z_Header() As MemoryBlock		  // Private method, only to be called by ZipArchive.z_writeDirectory()		  // Do not mess with it outside ZipArchive (use it read-only there)!		  return me.header		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function z_MBHdrLevel(mb as MemoryBlock) As Integer		  // Returns 0 if this is not a MacBinary header, otherwise the MB level (2-3)		  // The original MacBinary (version 1) format is not recognized since it's not		  // in use any more, and it's not safe for accurate detection (you can enable		  // MB 1 detection by calling EnableMacBinary1Detection(true), though).		  //		  // For documentation about MacBinary see http://www.lazerware.com/formats/		  		  dim mbLevel, i as Integer		  		  // first, make a few quick checks:		  if mb.Byte(0) = 0 and mb.Byte(82) = 0 and mb.Short(126) = 0 and mb.Long(83) >= 0 and mb.Long(87) >= 0 then		    i = mb.Byte(1)		    if i > 0 and i < 64 then		      i = mb.UShort(124)		      // now let's verify the CRC-16 checksum:		      if z_CRC(mb,124) = i then		        // it appears to be a valid MB header, check the level now:		        if mb.Long(102) = &H6D42494E then // 'mBIN'		          if mb.Byte(123) > 130 then		            mbLevel = 4 // this format unknown so far, indicating this by this higher number		          else		            mbLevel = 3		          end		        else		          mbLevel = 2		        end		      elseif me.supportMB1 and mb.Byte(1) < 32 then		        mbLevel = 1		      end		    end		  end		  		  return mbLevel		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function z_origEncodedComment() As String		  // private function to return the comment in the archive's encoding		  return me.zipEncComment		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function z_origEncodedName() As String		  // internal function. returns the name in the original encoding, not converted to the system's encoding		  return me.zipEncName		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub z_setAppleDoubleEntry(ze as ZipEntry)		  me.appleDoubleEntry = ze		  ze.thisIsTheAppleDoubleEntry = true		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub z_setError(errCode as Integer)		  if errCode = -1 then		    me.errmsg = "Incomplete"		  elseif errCode = -3 then		    me.errmsg = "Damaged"		  else		    me.errmsg = "Deflation error: "+Str(errCode)		  end		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub z_setup()		  		  #if TargetMacOS		    dim v as Integer		    call System.Gestalt("sysv", v)		    me.runningOnClassic = v < &H0A00		  #endif		  		  me.maxIntPlus1 = Pow(2.,31.)		  		  //		  // prepare the zlib prefix for "deflated" items		  //		  #if HaveEinhugurPlugin		    zlib_prefix = NewMemoryBlock(10)		    if zlib_prefix = nil then		      raise new OutOfMemoryException		    end		    zlib_prefix.LittleEndian = true		    zlib_prefix.Byte(0) = &h1f		    zlib_prefix.Byte(1) = &h8b		    zlib_prefix.Byte(2) = &h08		    zlib_prefix.Byte(3) = &h00		    zlib_prefix.Long(4) = &h00000000		    zlib_prefix.Byte(8) = &h00		    zlib_prefix.Byte(9) = &h07		  #else		    zlib_prefix = NewMemoryBlock(2)		    if zlib_prefix = nil then		      raise new OutOfMemoryException		    end		    zlib_prefix.LittleEndian = true		    zlib_prefix.Byte(0) = ZLibStream.Header1		    zlib_prefix.Byte(1) = ZLibStream.Header2		  #endif		  		  if me.header = nil then		    me.header = NewMemoryBlock(46)		    if me.header = nil then		      raise new OutOfMemoryException		    end		    me.header.LittleEndian = true		  end		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function z_ulongToDouble(i as Integer) As Double		  if i < 0 then		    return i + me.maxIntPlus1 + me.maxIntPlus1		  else		    return i		  end		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function z_unzip(dataOut as SeqDataOutputStream, rsrcOut as SeqDataOutputStream, decodeMB_in as Boolean, getMBHdrOnly as Boolean, ByRef mbHdr as MemoryBlock, ignoreBadMacMetadata as Boolean, ByRef abortedOut as Boolean) As Boolean		  // This is code is taken from Mieze (http://www.dietmar-plassmann.de/mieze.html)		  // Improved Mar 2003 by TT (www.tempel.org/rb/): can now handle folders, too, and does not use temp files any more		  		  dim dest as SeqDataOutputStream		  dim archiveReader as ZipBinaryStreamReader		  dim actuallyRead, uncompressedPos, rsrcForkStart, remaining, dataForkLen, rsrcForkLen as Int64		  dim originalLength, packedLength as Int64		  dim nxtAdjustment, amt, chunks as Int64		  dim CRC, cmp2, crc2, flg2 as UInt32		  dim NameLen, ExtraFieldLen, dummyInt, i as Integer		  dim comprMethod, flags as Integer		  dim mb2 as MemoryBlock		  dim monitor as ZipProgressNotifier		  dim isFake, rsrcOpened, splitForks, hadWriteError, hadError, decodeMB, getAppleDouble, abort as Boolean		  dim zipStream as BinaryStream		  #if HaveEinhugurPlugin		    dim decompressor as ZStream // 'ZStream' comes from "e-CryptIt Engine", see http://www.einhugur.com/		  #else		    dim decompressor as ZLibInflator		  #endif		  		  abortedOut = false		  		  decodeMB = decodeMB_in		  mbHdr = nil		  		  zipStream = me.d.zipStream		  		  if zipStream = nil then		    me.errmsg = "Archive is closed"		    return false		  end		  		  zipStream.Position = me.header.UInt32Value(42)		  		  i = zipStream.ReadLong // 50 4B 03 04   File Header Signature		  if i <> &h04034B50 then		    me.errmsg = "Invalid Local File Header signature (archive appears to be severely corrupted)"		    return false		  end		  		  dummyInt = zipStream.ReadShort // 14 00   Version needed to extract		  flags = zipStream.ReadShort // 00 00   General purpose bit Flag		  comprMethod = zipStream.ReadShort // 08 00   Compression Method (Deflate)		  dummyInt = zipStream.ReadShort //   Last Mod File Time in MS-DOS format		  dummyInt = zipStream.ReadShort //   Last Mod File Date in MS-DOS format		  CRC = zipStream.ReadUInt32 // CRC-32		  packedLength = zipStream.ReadUInt32 // Compressed Size		  originalLength = zipStream.ReadUInt32 // Uncompressed Size		  NameLen = zipStream.ReadShort // Filename Length		  ExtraFieldLen =  zipStream.ReadShort // Extra Field Length		  zipStream.Position = zipStream.Position + NameLen + ExtraFieldLen // skip the name and extras since we've got them already		  		  if me.thisIsTheAppleDoubleEntry then		    getAppleDouble = true		    decodeMB = false		  elseif decodeMB then		    if me.appleDoubleEntry <> nil then		      // we'll extract the MacBinary information from the AppleDouble header		      decodeMB = false		    elseif originalLength < 128 then		      // no MB hdr available		      if getMBHdrOnly then		        // we can stop right now		        return true // we had no errors		      end		      decodeMB = false		    end		  end		  		  if BitwiseAnd(flags,8) <> 0 then		    // this means that some fields in the local header are not set and need to be fetched from the directory header		    CRC = me.header.Long(16)		    packedLength = me.header.UInt32Value(20)		    originalLength = me.header.UInt32Value(24)		    if getAppleDouble and originalLength < 82 then		      // no ditto's AppleDouble hdr available		      if getMBHdrOnly then		        return true // we had no errors		      end		      me.errmsg = "The AppleDouble header is too short (<82 bytes)"		      return false		    end		  end		  		  // make sure the values match those from the directory		  cmp2 = me.header.UShort(10)		  crc2 = me.header.Long(16)		  flg2 = me.header.UShort(8)		  isFake = me.d.isFakeEntry(me.header,flags)		  if comprMethod <> cmp2 or CRC <> crc2 or packedLength <> me.CompressedSize or originalLength <> me.Size or (flags <> flg2) and not isFake then		    me.errmsg = "File Headers mismatch"		    return false		  end		  		  if BitwiseAnd(flags, &H01) <> 0 then		    // bit 0 is set -> archive is encrypted		    // We can not handle this case		    me.errmsg = "Unsupported format (encrypted)"		    return false		  end		  		  //		  // check the compression method		  //		  decompressor = nil		  if comprMethod = 8 then		    // "deflate" method		    #if HaveEinhugurPlugin		      mb2 = NewMemoryBlock(8) // prepare the zlib suffix with the CRC and expanded file len		      if mb2 = nil then		        raise new OutOfMemoryException		      end		      mb2.LittleEndian = true		      mb2.Long(0) = CRC		      mb2.UInt32Value(4) = originalLength		      archiveReader = new ZipBinaryStreamReader(zipStream, packedLength, zlib_prefix.StringValue(0,zlib_prefix.Size), mb2.StringValue(0,mb2.Size))		      decompressor = new ZStream(false, nil, archiveReader) // 'ZStream' comes from "e-CryptIt Engine" or its "#TypeLib.rbx" plugin, see http://www.einhugur.com/		      if decompressor.ErrorValue <> 0 then		        z_setError decompressor.ErrorValue		        return false		      end if		    #else		      archiveReader = new ZipBinaryStreamReader(zipStream, packedLength, zlib_prefix.StringValue(0,zlib_prefix.Size), "")		      decompressor = new ZLibInflator(archiveReader)		      decompressor.EnableCRCCalculation		    #endif		  elseif comprMethod = 0 then		    // "stored" (no compression)		  else		    // unsupported method		    me.errmsg = "Unsupported compression method ("+Str(comprMethod)+")"		    return false		  end		  		  //		  // copy the data from the archive to the destination file		  //		  		  // open the data fork		  if dataOut <> nil and not getMBHdrOnly then		    if not dataOut.Open() then		      me.errmsg = "Opening destination file failed"		      return false		    end		    dest = dataOut		  end		  		  // copy the data in chunks of at least 2KB to the dest file		  chunks = Max(2048,me.d.copyChunkSize)		  remaining = originalLength		  uncompressedPos = 0		  nxtAdjustment = 0		  monitor = me.d.monitor		  if monitor <> nil and not getMBHdrOnly then		    // notify the start of this item		    monitor.ZipProgress me, packedLength, 0, abort		  end		  		  		  while remaining > UInt32(0) and not abort		    		    // decide which fork is being read with the next chunk		    if splitForks then		      if dataForkLen > 0 then		        // read the data fork		        amt = Min(chunks+nxtAdjustment, dataForkLen)		        dataForkLen = dataForkLen- amt		      elseif uncompressedPos < rsrcForkStart then		        // skip the filler between data and rsrc fork		        amt = rsrcForkStart - uncompressedPos		        dest = nil		      elseif rsrcForkLen > 0 then		        if not rsrcOpened then		          // start reading the rsrc fork		          if dataOut <> nil then		            // close the data fork		            if not dataOut.Close() then		              hadWriteError = true		              exit		            end		          end		          if rsrcOut <> nil then		            // open the rsrc fork		            if not rsrcOut.Open() then		              me.errmsg = "Opening destination rsrc fork failed"		              return false		            end		          end		          dest = rsrcOut		          rsrcOpened = true		        end		        amt = Min(chunks+nxtAdjustment, rsrcForkLen)		        rsrcForkLen = rsrcForkLen- amt		      else		        // skip any data behind the rsrc fork		        dest = nil		        amt = Min(chunks+nxtAdjustment, remaining)		      end		    else		      amt = Min(chunks+nxtAdjustment, remaining)		    end		    nxtAdjustment = 0		    		    // if we need to look at the AppleDouble/MacBinary header, we only read this header for now (82 or 128 bytes)		    if getAppleDouble then		      amt = 82 // we already made sure above that the uncompressed file is at least 82 bytes in size		      nxtAdjustment = -82 // so that we get back to reading on proper chunk borders for speed		      if remaining > amt then		        // +++ there is more data. OS X 10.5's zip tool stores extended attributes here. We currently ignore them		      end		    elseif decodeMB then		      amt = 128 // we already made sure above that the uncompressed file is at least 128 bytes in size		      nxtAdjustment = -128 // so that we get back to reading on proper chunk borders for speed		    end		    		    // read the data		    dim readData as String		    if decompressor <> nil then		      readData = decompressor.Read(amt)		      #if HaveEinhugurPlugin		        if decompressor.ErrorValue <> 0 then		          if decompressor.ErrorValue <> 1 then		            hadError = true		            z_setError decompressor.ErrorValue		            // do not exit here so that we can still save the readData further down		          end		        end		      #else		        // let's just ignore any error states because we'll read 0 bytes in an error case,		        // which will be handled below		      #endif		    else		      readData = zipStream.Read(amt)		    end		    		    // now we have the uncompressed data in "readData"		    actuallyRead = LenB(readData)		    uncompressedPos = uncompressedPos + actuallyRead		    if not hadError and actuallyRead <> amt then		      // data error: we did not get what we asked for		      hadError = true		      me.errmsg = "Incomplete"		      me.endsPrematurely = true		    end		    		    if not hadError then		      // extract the MacBinary or AppleDouble information		      if getAppleDouble or decodeMB then		        if not z_unzipMBHdr (getAppleDouble, readData, mbHdr, rsrcForkStart) then		          hadError = true		          exit		        end		        if mbHdr <> nil then		          readData = ""		          splitForks = true		          dataForkLen = mbHdr.UInt32Value(83)		          rsrcForkLen = mbHdr.UInt32Value(87)		          if remaining < rsrcForkStart + rsrcForkLen then		            // data is corrupted		            exit		          end		        else		          // does not appear to be a MB header -> just write this out as a normal part of the file		        end		        decodeMB = false		        getAppleDouble = false		      end		    end		    if getMBHdrOnly then		      remaining = remaining - actuallyRead		      exit // we are finished with reading from the compressed stream		    end		    		    // store the decoded data		    if dest <> nil and readData.LenB > 0 then		      if not dest.Write(readData) then		        hadWriteError = true		        exit		      end		    end		    		    if hadError then		      exit		    end		    		    remaining = remaining - amt		    if monitor <> nil and remaining > 0 and archiveReader <> nil then		      monitor.ZipProgress me, packedLength, packedLength-archiveReader.Remaining, abort		    end		    		  wend		  		  // final check for valid CRC:		  if not abort and not hadError and decompressor <> nil then		    if getMBHdrOnly and remaining > 0 then		      // can happen with extended attribs in AppleDouble files created by OS X Leopard and later		    else		      dim readData as String, err as Integer		      readData = decompressor.Read(1) // attempt to read one more byte to check whether the compressed stream is at its end		      #if HaveEinhugurPlugin		        err = decompressor.ErrorValue		        if err <> 0 then		          z_setError err		          hadError = true		        elseif readData.LenB > 0 then		          me.errmsg = "File corrupted"		          hadError = true		        end		      #else		        if not decompressor.IsFinished then		          me.errmsg = "Compressed stream overflow"		          hadError = true		        elseif decompressor.CRC <> CRC then		          if me.endsPrematurely then		            me.errmsg = "Incomplete"		          else		            me.errmsg = "Checksum error"		          end		          hadError = true		        end		      #endif		    end		  end		  		  if monitor <> nil and not getMBHdrOnly then		    // notify user about completion of this item		    monitor.ZipProgress me, packedLength, packedLength, abort		  end		  		  // close the output streams		  if rsrcOut <> nil and not rsrcOut.Close then		    hadWriteError = true		  end		  if dataOut <> nil and not dataOut.Close then		    hadWriteError = true		  end		  		  if not hadError and not abort then		    if decodeMB_in and me.appleDoubleEntry <> nil then		      if not me.appleDoubleEntry.z_unzip (nil, rsrcOut, true, getMBHdrOnly, mbHdr, false, abort) then		        if ignoreBadMacMetadata then		          mbHdr = nil		        else		          me.errmsg = "Mac meta data is damaged: " + me.appleDoubleEntry.errmsg		          hadError = true		        end		      elseif mbHdr <> nil then		        mbHdr.UInt32Value(83) = uncompressedPos // update the data fork size because we did not get that from the AppleDouble header		      end		    end		  end		  		  if me.header.Long(24) = -1 then		    // length was not known, but it is now (even if it's a damaged item)		    me.header.UInt32Value(24) = uncompressedPos		  end		  		  //		  // finished copying the data		  //		  		  if abort then // this check must come first as an abort leads to follow-up errors which we want to override here		    me.errmsg = "Aborted"		    abortedOut = true		    return false		  end		  		  if hadError then		    // me.errmsg should already be set		    return false		  end		  		  if not hadWriteError then		    if not getMBHdrOnly then		      if uncompressedPos <> originalLength then		        me.errmsg = "Data appears to be corrupted"		        return false		      elseif archiveReader <> nil and archiveReader.Remaining() <> 0 then		        // Oops, this is strange, but we shouldn't flag it as an error, because some files, when compressed with		        // this program (and Einhugur's zlib), would just verify fine with other tools and uncompress even		        // with this program correctly, yet leave some remaining bytes in the archiveReader. One of these files is		        // "tts-zip-testfile-1"		        // Because of this, since 17Jul03 (v1.1.2), this case is not signalling an error any more.		        // Update 18Oct09 (v2.0): Can't reproduce this problem any more.		        break		      end		    end		  end		  		  if hadWriteError then		    me.errmsg = "File write error (disk full?)"		    return false		  end		  		  return true		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function z_unzipMBHdr(isAppleDouble as Boolean, data as String, ByRef mbHdr as MemoryBlock, ByRef rsrcForkStart as Int64) As Boolean		  // converts a AppleDouble header into a MacBinary header		  		  dim mb as MemoryBlock		  dim dummyInt, i as Integer		  		  mb = NewMemoryBlock(128)		  if mb = nil then		    raise new OutOfMemoryException		  end		  mb.LittleEndian = false		  if isAppleDouble then		    mbHdr = mb		    mb = NewMemoryBlock(LenB(data))		    if mb = nil then		      raise new OutOfMemoryException		    end		    mb.LittleEndian = false // !TT added 18Mac07 as I believe this is necessary (not tested, though)		    mb.StringValue(0,mb.Size) = data		    if mb.Long(0) <> &h00051607 or mb.Long(4) <> &h00020000 or mb.Short(24) <> 2 or mb.Long(26) <> 9 or mb.Long(34) < &h20  or mb.Long(38) <> 2 then		      // this is not a valid AppleDouble header, at least not one we expect here (as created by ditto)		      me.errmsg = "Invalid or unsupported AppleDouble header"		      return false		    end		    i = mb.Long(30) // offset into Finder Info		    mbHdr.StringValue(65,16) = mb.StringValue(i,16) // copy FInfo		    mbHdr.Byte(106) = mb.Byte(i+16+8) // copy FXInfo.fdScript		    mbHdr.Byte(107) = mb.Byte(i+16+9) // copy FXInfo.fdXFlags		    mbHdr.Byte(101) = mbHdr.Byte(74)		    mbHdr.Byte(74) = 0		    if me.extra.GetUnixTimes(dummyInt, i) then		      i = i+UnixToMacTimeOffset+UTCOffsetInMinutes*60 //convert Unix UTC into Mac local time		      mbHdr.Long(91) = i // creation date		      mbHdr.Long(95) = i // modification date		    end		    rsrcForkStart = mb.UInt32Value(42)		    mbHdr.UInt32Value(87) = mb.UInt32Value(46)		  else		    mb.StringValue(0,128) = data		    // check whether the MB header is valid		    if z_MBHdrLevel(mb) > 0 then		      mbHdr = mb		      rsrcForkStart = BitwiseAnd(255 + mb.Long(83), &HFFFFFF80)		    else		      // does not appear to be a MB header -> just write this out as a normal part of the file		    end		  end		  return true		End Function	#tag EndMethod	#tag Note, Name = About				See the notes in the class "ZipArchive" for more information	#tag EndNote	#tag Note, Name = Important				----------------------------------		Important note about adding Set... functions here		----------------------------------		  		We must not provide methods that allow the change of any ZipEntry		  properties other than the comment (comments are stored only in the dir)		  here, because altering any other properties would only be stored in		  the Central Directory structure, but not in the Local File Header,		  causing header mismatches.				So, if one wants to alter the name or the Extra Field of an item in the		  archive, the entire archived file needs to be rewritten (appended)		  with the current implemention of these classes. To overcome this		  limitation, one would have to move any data behind the modified		  entry, which can be quite inefficient with larger archives. Instead,		  the way to go is to Remove the original entry, then generate a new		  one and copy the compressed data over. The only exception is when		  the replacement will be the same size or smaller than the original.		  In case it's smaller, ZipArchive.Compact should be called afterwards.	#tag EndNote	#tag Property, Flags = &h1		Protected appleDoubleEntry As ZipEntry	#tag EndProperty	#tag Property, Flags = &h1		Protected d As ZipArchiveData	#tag EndProperty	#tag Property, Flags = &h1		Protected endsPrematurely As Boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected errmsg As String	#tag EndProperty	#tag Property, Flags = &h1		Protected extra As ZipExtraField	#tag EndProperty	#tag Property, Flags = &h1		Protected header As MemoryBlock	#tag EndProperty	#tag Property, Flags = &h1		Protected isFolder As Boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected lockFiles As Boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected maxIntPlus1 As Double	#tag EndProperty	#tag Property, Flags = &h1		Protected path(-1) As String	#tag EndProperty	#tag Property, Flags = &h1		Protected runningOnClassic As Boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected supportMB1 As Boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected sysEncComment As String	#tag EndProperty	#tag Property, Flags = &h1		Protected sysEncName As String	#tag EndProperty	#tag Property, Flags = &h1		Protected thisIsTheAppleDoubleEntry As Boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected zipEncComment As String	#tag EndProperty	#tag Property, Flags = &h1		Protected zipEncName As String	#tag EndProperty	#tag Property, Flags = &h0		Shared zlib_prefix As MemoryBlock	#tag EndProperty	#tag Property, Flags = &h0		z_hasDittoName As Boolean	#tag EndProperty	#tag Constant, Name = UnixToMacTimeOffset, Type = Integer, Dynamic = False, Default = \"2082844800", Scope = Public	#tag EndConstant	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="z_hasDittoName"			Group="Behavior"			InitialValue="0"			Type="Boolean"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass