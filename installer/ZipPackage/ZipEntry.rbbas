#tag ClassProtected Class ZipEntry	#tag Method, Flags = &h0		Function CompressedSize() As Integer		  return me.header.Long(20)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function RawPath() As String		  // Returns the path as it appears in the Zipfile's directory.		  //		  // It always uses "/" as directory separators, even on Mac OS Classic!		  //		  // So be careful: This name may not be the original file's path, because		  //   if the original name contained invalid DOS chars, such as "/",		  //   then this returns a cleaned up name!		  		  return me.sysEncName		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub GetPath(names() as String)		  // returns the file name and path in an array split by the directory separators		  		  dim i as Integer		  		  redim names(Ubound(me.path))		  for i = 0 to Ubound(me.path)		    names(i) = me.path(i)		  next		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function IsDirectory() As Boolean		  return me.isFolder		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Time() As Date		  // Returns the time stamp of the entry,		  //   returns nil if the time was not specified in the archive		  		  dim d as Date, tim, dat as Integer		  		  tim = me.header.UShort(12)		  dat = me.header.UShort(14)		  		  if tim = 0 and dat = 0 then		    return nil		  end		  		  d = new Date		  		  // convert date/time from DOS format		  d.Day = BitwiseAnd(dat,31)		  d.Month =  BitwiseAnd(dat,&H1E0) \ &H20		  d.Year = BitwiseAnd(dat,&H0FE00) \ &H0200 +1980		  d.Hour = BitwiseAnd(tim,&HF800) \ &H800		  d.Minute = BitwiseAnd(tim,&H7E0) \ &H20		  d.Second = 2 * BitwiseAnd(tim,&H1F)		  		  return d		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function IsEncrypted() As Boolean		  return BitwiseAnd(me.header.UShort(8),1) <> 0		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CanExtract() As Boolean		  dim i as Integer		  i = CompressionMethod()		  return (i = 0 or i = 8) and not IsEncrypted() and not IsDirectory()		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CompressionMethod() As Integer		  // common values:		  // 0: stored (not compressed - can always be read)		  // 1: shrunk (not supported)		  // 6: imploded (not supported)		  // 8: deflated (supported through e-CryptIt Engine plugin)		  		  return me.header.UShort(10)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Extract(destination as FolderItem) As Boolean		  // Same as Extract(destination as FolderItem, decodeMacBinary as Boolean),		  //   but with the difference that decodeMacBinary is always TRUE, which		  //   leads to properly extracted files on Mac OS system, and will extract		  //   the data fork only of files in MacBinary format on Windows systems,		  //   meaning that the (on Windows useless) Resource fork will be discarded		  //   on Windows systems, which is usually what people want.		  		  return Extract(destination, true)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub ZipEntry(archiveData as ZipArchiveData, hdr as MemoryBlock, origEncName as String, extra as ZipExtraField, origEncComment as String)		  // private constructor, to be used only by ZipArchive.readEntries		  		  me.d = archiveData		  		  me.header = hdr		  me.extra = extra		  me.zipEncName = origEncName		  me.zipEncComment = origEncComment		  		  me.sysEncName = me.d.decodeFromZip(me.zipEncName)		  me.sysEncComment = me.d.decodeFromZip(me.zipEncComment)		  		  if me.extra = nil then		    // me.extra must not be nil any more (since v1.1)		    me.extra = new ZipExtraField(me.d, "")		    me.extra.Lock		  end		  		  z_checkRawPath		  z_setup		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function Verify() As Boolean		  // Checks the integrity of the data by uncompressing it and verifying its CRC		  // Returns TRUE if data is valid.		  		  dim mb as MemoryBlock		  		  return z_unzip(nil, nil, false, false, mb)		  		exception err as RuntimeException		  me.errmsg = "Internal error (exception)"		  return false		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Comment() As String		  // Returns the optional comment about the entry. Returns empty string if no comment available		  		  return me.sysEncComment		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function z_unzip(dataOut as SeqDataOutputStream, rsrcOut as SeqDataOutputStream, decodeMB_in as Boolean, getMBHdrOnly as Boolean, ByRef mbHdr as MemoryBlock) As Boolean		  // This is code is taken from Mieze (http://www.dietmar-plassmann.de/mieze.html)		  // Improved Mar 2003 by TT (www.tempel.org/rb/): can now handle folders, too, and does not use temp files any more		  		  dim dest as SeqDataOutputStream		  dim reader as ZipBinaryStreamReader		  dim f as FolderItem		  dim uncompressedPos, CRC, ISize, GepackteLaenge as Integer		  dim NameLen, ExtraFieldLen, dummyInt, i as Integer		  dim remaining, chunks as Integer		  dim actuallyRead, nxtAdjustment, flags, amt, comprMethod as Integer		  dim mb, mb2 as MemoryBlock		  dim s as String		  dim monitor as ZipProgressNotifier		  dim isFake, rsrcOpened, splitForks, hadWriteError, hadError, decodeMB, getAppleDouble, abort as Boolean		  dim zipStream as BinaryStream		  dim cmp2, crc2, flg2, dataForkLen, rsrcForkStart, rsrcForkLen as Integer		  #if HaveEinhugurPlugin		    dim df as ZStream // 'ZStream' comes from "e-CryptIt Engine", see http://www.einhugur.com/		  #else		    dim df as ZipBinaryStreamReader		  #endif		  		  decodeMB = decodeMB_in		  mbHdr = nil		  		  zipStream = me.d.zipStream		  		  if zipStream = nil then		    me.errmsg = "Archive is closed"		    return false		  end		  		  zipStream.Position = me.header.Long(42)		  		  i = zipStream.ReadLong // 50 4B 03 04   File Header Signature		  if i <> &h04034B50 then		    me.errmsg = "Invalid Local File Header signature (archive appears to be severely corrupted)"		    return false		  end		  		  dummyInt = zipStream.ReadShort // 14 00   Version needed to extract		  flags = zipStream.ReadShort // 00 00   General purpose bit Flag		  comprMethod = zipStream.ReadShort // 08 00   Compression Method (Deflate)		  dummyInt = zipStream.ReadShort //   Last Mod File Time in MS-DOS format		  dummyInt = zipStream.ReadShort //   Last Mod File Date in MS-DOS format		  CRC = zipStream.ReadLong // CRC-32		  GepackteLaenge = zipStream.ReadLong // Compressed Size		  ISize = zipStream.ReadLong // Uncompressed Size		  NameLen = zipStream.ReadShort // Filename Length		  ExtraFieldLen =  zipStream.ReadShort // Extra Field Length		  zipStream.Position = zipStream.Position + NameLen + ExtraFieldLen // skip the name and extras since we've got them already		  		  if me.thisIsTheAppleDoubleEntry then		    getAppleDouble = true		    decodeMB = false		  elseif decodeMB then		    if me.appleDoubleEntry <> nil then		      // we'll extract the MacBinary information from the AppleDouble header		      decodeMB = false		    elseif ISize < 128 then		      // no MB hdr available		      if getMBHdrOnly then		        // we can stop right now		        return true // we had no errors		      end		      decodeMB = false		    end		  end		  		  if BitwiseAnd(flags,8) <> 0 then		    // this means that some fields in the local header are not set and need to be fetched from the directory header		    CRC = me.header.Long(16)		    GepackteLaenge = me.header.Long(20)		    ISize = me.header.Long(24)		    if getAppleDouble and ISize < 82 then		      // no ditto's AppleDouble hdr available		      if getMBHdrOnly then		        return true // we had no errors		      end		      me.errmsg = "The AppleDouble header is too short (<82 bytes)"		      return false		    end		  end		  		  // make sure the values match those from the directory		  cmp2 = me.header.UShort(10)		  crc2 = me.header.Long(16)		  flg2 = me.header.UShort(8)		  isFake = me.d.isFakeEntry(me.header,flags)		  if comprMethod <> cmp2 or CRC <> crc2 or GepackteLaenge <> me.CompressedSize or ISize <> me.Size or (flags <> flg2) and not isFake then		    me.errmsg = "File Headers mismatch"		    return false		  end		  		  if BitwiseAnd(flags, &H01) <> 0 then		    // bit 0 is set -> archive is encrypted		    // We can not handle this case		    me.errmsg = "Unsupported format (encrypted)"		    return false		  end		  		  //		  // check the compression method		  //		  df = nil		  if comprMethod = 8 then		    if not HaveEinhugurPlugin then		      me.errmsg = "Can't deflate because of missing compression plugin"		      return false		    end		    // "deflate" method		    mb2 = NewMemoryBlock(8) // prepare the zlib suffix with the CRC and expanded file len		    if mb2 = nil then		      raise new OutOfMemoryException		    end		    mb2.LittleEndian = true		    mb2.Long(0) = CRC		    mb2.Long(4) = ISize		    reader = new ZipBinaryStreamReader(zipStream, GepackteLaenge, zlib_prefix.StringValue(0,zlib_prefix.Size), mb2.StringValue(0,mb2.Size))		    #if HaveEinhugurPlugin		      df = new ZStream(false, nil, reader) // 'ZStream' comes from "e-CryptIt Engine" or its "#TypeLib.rbx" plugin, see http://www.einhugur.com/		    #endif		    if df.ErrorValue <> 0 then		      me.errmsg = "An error "+Str(df.ErrorValue)+" occured while deflation"		      return false		    end if		  elseif comprMethod = 0 then		    // "stored" (no compression)		  else		    // unsupported method		    me.errmsg = "Unsupported compression method ("+Str(comprMethod)+")"		    return false		  end		  		  //		  // copy the data from the archive to the destination file		  //		  		  // open the data fork		  if dataOut <> nil and not getMBHdrOnly then		    if not dataOut.Open() then		      me.errmsg = "Opening destination file failed"		      return false		    end		    dest = dataOut		  end		  		  // copy the data in chunks of at least 2KB to the dest file		  chunks = Max(2048,me.d.copyChunkSize)		  remaining = ISize		  uncompressedPos = 0		  nxtAdjustment = 0		  monitor = me.d.monitor		  if monitor <> nil and not getMBHdrOnly then		    // notify the start of this item		    monitor.ZipProgress me, ISize, 0, abort		  end		  		  while remaining > 0 and not abort		    		    // decide which fork is being read with the next chunk		    if splitForks then		      if dataForkLen > 0 then		        // read the data fork		        amt = Min(chunks+nxtAdjustment, dataForkLen)		        dataForkLen = dataForkLen- amt		      elseif uncompressedPos < rsrcForkStart then		        // skip the filler between data and rsrc fork		        amt = rsrcForkStart - uncompressedPos		        dest = nil		      elseif rsrcForkLen > 0 then		        if not rsrcOpened then		          // start reading the rsrc fork		          if dataOut <> nil then		            // close the data fork		            if not dataOut.Close() then		              hadWriteError = true		              exit		            end		          end		          if rsrcOut <> nil then		            // open the rsrc fork		            if not rsrcOut.Open() then		              me.errmsg = "Opening destination rsrc fork failed"		              return false		            end		          end		          dest = rsrcOut		          rsrcOpened = true		        end		        amt = Min(chunks+nxtAdjustment, rsrcForkLen)		        rsrcForkLen = rsrcForkLen- amt		      else		        // skip any data behind the rsrc fork		        dest = nil		        amt = Min(chunks+nxtAdjustment, remaining)		      end		    else		      amt = Min(chunks+nxtAdjustment, remaining)		    end		    nxtAdjustment = 0		    		    // if we need to look at the AppleDouble/MacBinary header, we only read this header for now (82 or 128 bytes)		    if getAppleDouble then		      amt = 82 // we already made sure above that the uncompressed file is at least 82 bytes in size		      nxtAdjustment = -82 // so that we get back to reading on proper chunk borders for speed		    elseif decodeMB then		      amt = 128 // we already made sure above that the uncompressed file is at least 128 bytes in size		      nxtAdjustment = -128 // so that we get back to reading on proper chunk borders for speed		    end		    		    // read the data		    if df <> nil then		      s = df.Read(amt)		      if df.ErrorValue <> 0 then		        if df.ErrorValue <> 1 then		          hadError = true		          me.errmsg = "An error "+Str(df.ErrorValue)+" occured while deflation"		          exit		        end		      end		    else		      s = zipStream.Read(amt)		    end		    		    // now we have the uncompressed data in "s"		    actuallyRead = LenB(s)		    uncompressedPos = uncompressedPos + actuallyRead		    if actuallyRead <> amt then		      exit // data error: we did not get what we asked for		    end		    		    // extract the MacBinary or AppleDouble information		    if getAppleDouble or decodeMB then		      if not z_unzipMBHdr (getAppleDouble, s, mbHdr, rsrcForkStart) then		        hadError = true		        exit		      end		      if mbHdr <> nil then		        s = ""		        splitForks = true		        dataForkLen = mbHdr.Long(83)		        rsrcForkLen = mbHdr.Long(87)		        if remaining < rsrcForkStart + rsrcForkLen then		          // data is corrupted		          exit		        end		      else		        // does not appear to be a MB header -> just write this out as a normal part of the file		      end		      decodeMB = false		      getAppleDouble = false		    end		    if getMBHdrOnly then		      exit // we are finished with reading from the compressed stream		    end		    		    // store the data		    if dest <> nil then		      if not dest.Write(s) then		        hadWriteError = true		        exit		      end		    end		    remaining = remaining - amt		    if monitor <> nil and remaining > 0 then		      monitor.ZipProgress me, ISize, ISize-remaining, abort		    end		    		  wend		  		  if monitor <> nil and not getMBHdrOnly then		    // notify the finishing of this item		    monitor.ZipProgress me, ISize, ISize, abort		  end		  		  // close the streams		  if rsrcOut <> nil and not rsrcOut.Close then		    hadWriteError = true		  end		  if dataOut <> nil and not dataOut.Close then		    hadWriteError = true		  end		  		  if not hadError then		    if decodeMB_in and me.appleDoubleEntry <> nil then		      if not me.appleDoubleEntry.z_unzip (nil, rsrcOut, true, getMBHdrOnly, mbHdr) then		        me.errmsg = me.appleDoubleEntry.errmsg		        hadError = true		      elseif mbHdr <> nil then		        mbHdr.Long(83) = ISize // update the data fork size because we did not get that from the AppleDouble header		      end		    end		  end		  		  //		  // finished copying the data		  //		  		  if hadError then		    // me.errmsg should already be set		    return false		  end		  		  if abort then		    me.errmsg = "Aborted"		    return false		  end		  		  if not hadWriteError then		    if uncompressedPos <> ISize then		      me.errmsg = "Data appears to be corrupted"		      return false		    elseif reader <> nil and reader.Remaining() <> 0 then		      // Oops, this is strange, but we shouldn't flag it as an error, because some files, when compressed with		      // this program (and Einhugur's zlib), would just verify fine with other tools and uncompress even		      // with this program correctly, yet leave some remaining bytes in the reader. One of these files is		      // "tts-zip-testfile-1"		      // Because of this, since 17Jul03 (v1.1.2), this case is not signalling an error any more.		    end		  end		  		  if hadWriteError then		    me.errmsg = "File write error (disk full?)"		    return false		  end		  		  return true		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub z_setup()		  		  #if TargetMacOS		    dim v as Integer		    call System.Gestalt("sysv", v)		    me.runningOnClassic = v < &H0A00		  #endif		  		  me.maxIntPlus1 = Pow(2,31)		  		  //		  // prepare the zlib prefix for "deflated" items		  //		  zlib_prefix = NewMemoryBlock(10)		  if zlib_prefix = nil then		    raise new OutOfMemoryException		  end		  zlib_prefix.LittleEndian = true		  zlib_prefix.Byte(0) = &h1f		  zlib_prefix.Byte(1) = &h8b		  zlib_prefix.Byte(2) = &h08		  zlib_prefix.Byte(3) = &h00		  zlib_prefix.Long(4) = &h00000000		  zlib_prefix.Byte(8) = &h00		  zlib_prefix.Byte(9) = &h07		  		  if me.header = nil then		    me.header = NewMemoryBlock(46)		    if me.header = nil then		      raise new OutOfMemoryException		    end		    me.header.LittleEndian = true		  end		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function ErrorMessage() As String		  // Returns a desciption about the latest error as an english phrase		  //		  // Functions calls that could cause such an error:		  // - Extract()		  // - Verify()		  // - SetPath() (the one returning a Boolean result)		  // - ExtraField()		  		  return me.errmsg		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function MakeDestination(root as FolderItem, followAliases as Boolean) As FolderItem		  // Creates a FolderItem object for the original path given by the archive entry.		  // Will create intermittent folders if necessary.		  //		  // Caution: "nil" may be returned if followAliases=false and an Alias exists at that place already,		  // or when a file exists where a folder is desired by the destination path		  		  dim dest as FolderItem, i as Integer		  dest = root		  for i = 0 to Ubound(me.path)		    dest = MakeDestinationChild(dest, me.path(i), followAliases)		  next		  return dest		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Extract(decodeMacBinary as Boolean, dataOut as SeqDataOutputStream, rsrcOut as SeqDataOutputStream, ByRef mbHdr as MemoryBlock) As Boolean		  // Writes the data of this entry to one or two streams.		  // If decodeMacBinary is FALSE or if the data is not MacBinary encoded, then all data is written to the		  //   dataOut stream, and rsrcOut is not used.		  // If decodeMacBinary is TRUE and if the data is MacBinary encoded, the two forks are streamed to dataOut		  //   and rsrcOut, respectively. If either of the two stream parameters is nil, their fork will be skipped;		  //   mbHdr will be set to a MemoryBlock of size 128 containing the MacBinary header. This works even		  //   on folders which have a MacBinary header.		  // The streams will be opened and closed by this function as needed.		  // Returns TRUE if the extraction was successful. FALSE might mean a bad CRC or other data or writing errors.		  		  dim mb as MemoryBlock, ok as Boolean		  		  mbHdr = nil		  		  if dataOut = nil and rsrcOut = nil and decodeMacBinary = false then		    // this makes no sense -> alert the programmer		    raise new RuntimeException		  end		  		  ok = z_unzip(dataOut, rsrcOut, decodeMacBinary, me.isFolder, mb)		  		  mbHdr = mb		  		  return ok		  		exception err as RuntimeException		  me.errmsg = "Internal error (exception)"		  return false		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Size() As Integer		  return me.header.Long(24)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub SetComment(comment as String)		  // Sets the entry's comment that'll be stored in the archive		  // when the directory is written (by ZipArchive.Close or		  // ZipArchive.Flush)		  		  me.sysEncComment = comment		  		  me.zipEncComment = me.d.encodeForZip(me.sysEncComment)		  me.d.dirty = true		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function ExtraFieldInCentralDir() As ZipExtraField		  // Returns the Extra Field from the Central Directory Header, which may be different from		  // the one in the Local Header -- If they differ, this one may leave out some information,		  // while the other one contains all the infos (see the Zip Archive specs).		  // Accessing this one is faster, however, since it's already cached in memory, while		  // the Extra Field in the Local Header must still be read from the archive.		  		  if not me.extra.IsLocked then		    // this would be an internal error - this obj must have been locked when it was passed to ZipEntry		    raise new RuntimeException		  end		  		  return me.extra // must not be nil any more (since v1.1)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function z_Header() As MemoryBlock		  // Private method, only to be called by ZipArchive.z_writeDirectory()		  // Do not mess with it outside ZipArchive (use it read-only there)!		  return me.header		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub z_checkRawPath()		  dim ch, s as String, i, len as Integer		  		  //		  // extract folders from the full file name		  //		  redim me.path(-1)		  me.isFolder = false		  len = LenB(me.sysEncName)		  for i = 1 to len		    ch = MidB(me.sysEncName, i, 1)		    if ch = ":" then		      // ":" is an illegal char in Mac OS file names, so we need to replace it with something else		      if EmulateOSXRenaming and TargetMacOS then		        ch = "/" // this is what Mac OS X's zip does		      else		        ch = "-" // this is what MacZipIt does		      end		    elseif ch = "/" then		      if i = len then		        // it's a just folder, not a file (its size may still be non-zero, that happens if the folder contains MacBinary information)		        me.isFolder = true		      end		      if s = "." then		        // ignore		      else		        me.path.append s		      end		      s = ""		    else		      s = s + ch		    end		  next		  if s <> "" then		    me.path.append s		  end		  		  if Left (s, 2) = "._" then		    me.z_hasDittoName = true		  elseif Ubound(me.path) >= 0 and StrComp ("__MACOSX", me.path(0), 0) = 0 then		    me.z_hasDittoName = true		  end		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function z_icMapFilename(filename as String, ByRef type as String, ByRef creator as String) As Boolean		  #if TargetMacOS		    		    dim errorCode as integer		    dim instancePointer as MemoryBlock		    dim mb, mb2 as memoryBlock		    dim ok as Boolean		    		    #if TargetCarbon		      declare function ICMapFilename lib CarbonLibName (instance as ptr, filename as pString, entry as ptr) as integer		      declare function ICStart lib CarbonLibName (instance as ptr, creator as cString) as integer		      declare function ICStop lib CarbonLibName (instance as ptr) as integer		    #else		      declare function ICStop lib "ICAp;InternetConfigLib" (instance as ptr) as integer		      declare function ICMapFilename lib "ICAp;InternetConfigLib" (instance as ptr, filename as pString, entry as ptr) as integer		      declare function ICStart lib "ICAp;InternetConfigLib" (instance as ptr, creator as cString) as integer		      declare function ICFindConfigFile lib "ICAp;InternetConfigLib" (instance as ptr, count as integer, ICDirSpecArrayPtr as integer) as integer		    #endif		    		    instancePointer = NewMemoryBlock(4)		    if instancePointer = nil then		      raise new OutOfMemoryException		    end		    errorCode=ICStart(instancePointer,"TTZp")		    if errorCode=0 then		      #if TargetCarbon		      #else		        errorCode = ICFindConfigFile(instancePointer.ptr(0),0,0)		      #endif		      if errorCode=0 then		        mb2 = newMemoryBlock(1302)		        if mb2 = nil then		          raise new OutOfMemoryException		        end		        mb2.LittleEndian = false		        errorCode = ICMapFilename(instancePointer.ptr(0), filename, mb2)		        if errorCode = 0 then		          type = mb2.StringValue(6, 4)		          creator = mb2.StringValue(10, 4)		          ok = true		        end if		      end if		      errorCode=ICStop(instancePointer.ptr(0))		    end if		    		    return ok		    		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Extract(destination as FolderItem, decodeMacBinary as Boolean) As Boolean		  // Same as Extract(destination as FolderItem, decodeMacBinary as Boolean, makeExecutable as Boolean),		  //   but with the difference that decodeMacBinary and makeExecutable are always TRUE, which		  //   leads to properly extracted and runnable files on Mac OS system, and will extract		  //   the data fork only of files in MacBinary format on Windows systems,		  //   meaning that the (on Windows useless) Resource fork will be discarded		  //   on Windows systems, which is usually what people want.		  		  return Extract(destination, true, true)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetMacBinaryHeader(ByRef mbHdr as MemoryBlock) As Boolean		  // Returns TRUE if the item is stored in MacBinary format. Will		  //   also return the 128 Byte long MacBinary header in this case.		  // Returns FALSE otherwise, along with setting "mbHdr" to nil.		  //		  // The Type and Creator can be retrieved as follows:		  //   MacType = mbHdr.StringValue(65,4)		  //   MacCreator = mbHdr.StringValue(69,4)		  //   DataForkSize = mbHdr.Long(83)		  //   RsrcForkSize = mbHdr.Long(87)		  //		  // You may also call ApplyMacBinaryInformation() to apply Type, Creator and		  //   other file/folder attributes from the MacBinary header to a file or folder.		  //		  // For more information on the MacBinary format, see:		  //   http://www.lazerware.com/formats/		  		  dim mb as MemoryBlock		  		  mbHdr = nil		  		  if not z_unzip(nil, nil, true, true, mb) then		    return false		  end		  		  me.errmsg = ""		  mbHdr = mb		  return mbHdr <> nil		  		Exception err as RuntimeException		  me.errmsg = "Internal error (exception)"		  return false		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function z_MBHdrLevel(mb as MemoryBlock) As Integer		  // Returns 0 if this is not a MacBinary header, otherwise the MB level (2-3)		  // The original MacBinary (version 1) format is not recognized since it's not		  // in use any more, and it's not safe for accurate detection (you can enable		  // MB 1 detection by calling EnableMacBinary1Detection(true), though).		  //		  // For documentation about MacBinary see http://www.lazerware.com/formats/		  		  dim mbLevel, i as Integer		  		  // first, make a few quick checks:		  if mb.Byte(0) = 0 and mb.Byte(82) = 0 and mb.Short(126) = 0 and mb.Long(83) >= 0 and mb.Long(87) >= 0 then		    i = mb.Byte(1)		    if i > 0 and i < 64 then		      i = mb.UShort(124)		      // now let's verify the CRC-16 checksum:		      if z_CRC(mb,124) = i then		        // it appears to be a valid MB header, check the level now:		        if mb.Long(102) = &H6D42494E then // 'mBIN'		          if mb.Byte(123) > 130 then		            mbLevel = 4 // this format unknown so far, indicating this by this higher number		          else		            mbLevel = 3		          end		        else		          mbLevel = 2		        end		      elseif me.supportMB1 and mb.Byte(1) < 32 then		        mbLevel = 1		      end		    end		  end		  		  return mbLevel		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub ApplyMacBinaryInformation(f as FolderItem, mbHdr as MemoryBlock)		  // You may use this function after calling Extract(outputStream as BinaryStream)		  //   in order to update your extracted file's Type, Creator and other Finder information.		  //  This call has even a little effect under Windows OS: If the MacBinary header		  //   specifies that the item was invisible (hidden), or read-only, these attributes		  //   will be applied under Windows to the file, too.		  //		  // Parameters:		  //   f: the file or folder you want the MB information applied to		  //   mbHdr: the MacBinary header. Retrieve it by calling GetMacBinaryHeader(mbHdr)		  //		  // Preconditions:		  // - f.Exists = true		  // - mbHdr <> nil		  		  dim spec, pb as MemoryBlock, res as Integer		  dim date1, date2 as Date		  		  if not f.Exists or mbHdr = nil then		    return		  end		  		  mbHdr.LittleEndian = false		  		  // !TT 21Jun05 - Fixed setting of creation date. For some strange reason one cannot modify the TotalSeconds property of f.CreationDate directly but must use an interim Date object for this		  date1 = new Date		  date2 = new Date		  date1.TotalSeconds = z_ulongToDouble(mbHdr.Long(91)) // creation date		  date2.TotalSeconds = z_ulongToDouble(mbHdr.Long(95)) // modification date		  f.CreationDate = date1		  f.ModificationDate = date2		  		  z_adjustMacFilename mbHdr.PString(1), mbHdr.Byte(106), f		  		  #if TargetMacOS		    		    if not f.Directory then		      f.MacType = mbHdr.StringValue(65,4)		      f.MacCreator = mbHdr.StringValue(69,4)		    end		    		    ///////////////////////////		    // apply FInfo + FXInfo		    		    #if TargetMacOS		      #if TargetMachO and AvoidFSSpecCalls		        Declare Function PBGetCatalogInfoSync Lib CarbonLibName (FSRefParam as Ptr) as Integer		        Declare Function PBSetCatalogInfoSync Lib CarbonLibName (FSRefParam as Ptr) as Integer		      #else		        Declare Function PBGetCatInfoSync Lib CarbonLibName (paramBlock as Ptr) as Integer		        Declare Function PBSetCatInfoSync Lib CarbonLibName (paramBlock as Ptr) as Integer		      #endif		    #endif		    #if TargetMachO and AvoidFSSpecCalls		      ... still missing ###		    #else		      spec = me.d.FSSpecOfFolderItem (f)		      pb = NewMemoryBlock(108)		      if pb = nil then		        raise new OutOfMemoryException		      end		      pb.Ptr(18) = spec		      pb.Long(18) = pb.Long(18) + 6		      pb.Short(22) = spec.Short(0)		      pb.Long(48) = spec.Long(2)		      res = PBGetCatInfoSync(pb)		      if res <> 0 then		        beep		      else		        pb.Byte(32+8) = BitwiseAnd(&HFF-&H11,mbHdr.Byte(73)) // FInfo.fdFlags (hi), but clear "hasBeenInited" and "nameLocked" flags		        pb.Byte(32+9) = mbHdr.Byte(101) // FInfo.fdFlags (lo)		        pb.Byte(84+8) = mbHdr.Byte(106) // FXInfo.fdScript		        pb.Byte(84+9) = mbHdr.Byte(107) // FXInfo.fdXFlags		        pb.Long(48) = spec.Long(2)		        res = PBSetCatInfoSync(pb)		      end		    #endif		    		    //		    ///////////////////////////		    		  #else		    		    f.Visible = BitwiseAnd(mbHdr.Byte(73),&H40) = 0		    		  #endif		  		  if me.lockFiles and mbHdr.Byte(81) <> 0 and not f.Directory then		    f.Locked = true //Note: this one must come last, or changes to other properties may not work		  end		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function z_CRC(mb as MemoryBlock, size as Integer) As Integer		  dim c as Integer		  		  #if HaveEinhugurPlugin		    // using the "e-CryptIt Engine" plugin, see <http://www.einhugur.com/>:		    c = Crc16_MemoryBlock(mb, 0, size, 0)		  #else		    // using the free but a bit outdated "TT's CRC-Plugin" from http://www.tempel.org/rb/		    return CRC_CCITTOfStr(mb.StringValue(0,size))		  #endif		  		  if c < 0 then		    c = c + 65536		  end		  		  return c		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function z_ulongToDouble(i as Integer) As Double		  if i < 0 then		    return i + me.maxIntPlus1 + me.maxIntPlus1		  else		    return i		  end		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function z_origEncodedName() As String		  // internal function. returns the name in the original encoding, not converted to the system's encoding		  return me.zipEncName		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function z_origEncodedComment() As String		  // private function to return the comment in the archive's encoding		  return me.zipEncComment		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub z_adjustMacFilename(macName as String, script as Integer, f as FolderItem)		  // Re-apply the file name from the MB header		  // This is useful in cases where the name in the zip directory was converted to match DOS requirements (e.g. no "/" in name)		  		  #if TargetMacOS		    		    #if TargetCarbon		      Declare Function GetScriptManagerVariable Lib CarbonLibName (selector as Integer) as Integer		    #else		      Declare Function GetScriptManagerVariable Lib "InterfaceLib" (selector as Integer) as Integer		    #endif		    		    //		    // This is difficult, however, since there are two scenarios which compete with each other:		    // 1. The original file had invalid DOS chars, e.g. "name/name". The file name at this point is "name-name", but we want to restore the orig name		    // 2. The original name had > 31 chars, which is stored inside the dir, but the MacBinary info stored a shortened name such as "...#12345.txt"		    //     In this second case, we do not want to restore the name		    // The complicated part is that both cases can be combined: A long name with "/" in it. That one can't possibly be restored.		    //		    // Since long names are usually only created on systems other than Mac OS Classic, i.e. Mac OS X or Windows, where the "/" is not		    // allowed in file names, it's rather unlikely to run into this problem of a long name with "/" - and if, we'll just leave it with the		    // modified long name (without the "/" in it).		    //		    // What remains is to detect whether case 1 or case 2 applies, and only make the modification in case 1		    // We do that by looking at the MacBinary name and converting that into a DOS-valid name. If that name		    // matches the name from the zip directory, then we have case 1 and rename the file		    		    dim te as TextEncoding		    		    if BitwiseAnd(script,&H80) = 0 then		      te = GetFontTextEncoding("System")		    else		      te = GetTextEncoding(BitwiseAnd(script,&H7F))		    end		    if te <> nil then		      macName = macName.DefineEncoding(te)		      if macName <> "" and f.Name <> macName then		        if f.Name = me.d.cleanName(macName) then		          // we have case 1		          if f.Name = me.path(Ubound(me.path)) then // make sure the actual file name matches the one from the zip file's directory		            f.Name = macName		          end		        end		      end		    end		    		  #endif		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function SameRawPath(rawPath as String) As Boolean		  // Use this function if you want to see if a given path is equal to		  // the one of this entry. Do not get the path using RawPath()		  // and then compare yourself, because that might fail with		  // non-ASCII characters in file names that are unicode encoded		  // (this is because there are several different ways to encode		  // the same non-ASCII character, and it happens under Mac OS		  // that exactly this will happen: "ä" <> "ä"). This function takes		  // care of this problem.		  		  return me.d.encodeForZip(rawPath) = me.zipEncName		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function MakeDestinationChild(dir as FolderItem, pathItem as String, followAliases as Boolean) As FolderItem		  dim dest as FolderItem, s as String		  dest = dir		  s = me.d.decodeFromZip(me.d.encodeForZip(pathItem))		  if s = ".." then		    dest = dest.Parent		  elseif s <> "" then		    if not dest.exists then		      dest.CreateAsFolder		    end		    if followAliases then		      dest = dest.Child(s)		    else		      dest = dest.TrueChild(s)		    end		  end		  return dest		Exception exc as RuntimeException		  return nil		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function IsTextFile() As Boolean		  // This information is currently (24Apr03) not used inside the Zip package.		  // That means: if a text file is extracted, no changes to the end-of-line chars		  // will be made.		  		  return BitwiseAnd(me.header.UShort(36),1) <> 0		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub SetTextFileFlag(isText as Boolean)		  // If you set the "text file" flag, note that the text should use CR+LF end-of-line (EOL)		  // delimiters because the items are marked to be in MS-DOS format, where these		  // EOLs are used for text files. Otherwise, tools that extract such items might not be		  // able to  convert the line endings properly.		  		  if isText then		    me.header.UShort(36) = BitwiseOr(me.header.UShort(36), 1)		  else		    me.header.UShort(36) = BitwiseAnd(me.header.UShort(36), 65535-1)		  end		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function OSMadeBy() As Integer		  // Read: "OS made by"		  //		  // Returns the code of the OS that this entry is using for file name encoding and		  // text file end-of-line format.		  // See the "PKZIP format.txt" or any "appnote.txt" on the web for the codes		  //		  // Call SetOSMadeBy() to change the value. Default for newly created items is 0		  // (This default can be changed using ZipArchive.SetDefaultOSMadeBy)		  		  return me.header.Byte(5)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub SetOSMadeBy(code as Integer)		  // See the "PKZIP format.txt" or any "appnote.txt" on the web for the codes		  //		  // Call OSMadeBy() to inquire about the current value		  		  me.header.Byte(5) = code		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetExtraFieldInCentralDir(extraField as ZipExtraField)		  // Sets a new Extra Field for the Central Directory only. Use this function		  // if you want to add an Extra Field that differs between the two Headers.		  // To achieve this, first create the "long" Extra Field and provide it when		  // you add the file to the archive. After that, call this function to set		  // the Extra Field in the Central Dir Header.		  		  dim ef as ZipExtraField		  		  ef = extraField		  if ef = nil then		    ef = new ZipExtraField(me.d, "")		  end		  ef.Lock		  me.extra = ef		  me.header.UShort(30) = LenB(ef.AsData())		  me.d.dirty = true		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function ExtraField() As ZipExtraField		  // Returns the Extra Field from the Local Header, which may be different from the one in		  // the Central Directory Header -- If they differ, this one is always the one with all the infos,		  // while the other one may leave out some information (see the Zip Archive specs).		  // Accessing this one is a bit slower, however, since it must still be read from the archive,		  // while the Extra Field in the Local Header is already cached in memory.		  //		  // If an error occured, nil will be returned, otherwise a valid object is returned, even if the Extra Field is empty		  		  dim lastpos, NameLen, ExtraFieldLen, i as Integer		  dim mb as MemoryBlock		  dim s as String		  dim zipStream as BinaryStream		  dim extra as ZipExtraField		  		  zipStream = me.d.zipStream		  		  if zipStream = nil then		    me.errmsg = "Archive is closed"		    return nil		  end		  		  lastpos = zipStream.Position		  zipStream.Position = me.header.Long(42)		  		  i = zipStream.ReadLong // 50 4B 03 04   File Header Signature		  if i <> &h04034B50 then		    zipStream.Position = lastpos		    me.errmsg = "Invalid Local File Header signature (archive appears to be severely corrupted)"		    return nil		  end		  		  zipStream.Position = zipStream.Position+22		  		  NameLen = zipStream.ReadShort // Filename Length		  ExtraFieldLen =  zipStream.ReadShort // Extra Field Length		  zipStream.Position = zipStream.Position + NameLen		  		  extra = new ZipExtraField(me.d, zipStream.Read(ExtraFieldLen))		  extra.Lock		  		  zipStream.Position = lastpos		  		  return extra		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub EnableMacBinary1Detection(enabled as Boolean)		  // By default, the outdated "MacBinary I" format will not be detected. Some zip and MB encoding		  // tools on other platforms may create incorrect or those outdated MB-headers.		  // If you enabable this mode, they're more likely to be detected as being MB-headers.		  // This feature comes with a risk, however: Normal files, that are not MB-encoded, might		  // mistakenly believed to be MB-encoded, in seldom cases. For that reason, enable this		  // feature only in cases where you believe you need it, but not be default!		  //		  // To use this feature, you must call this function before you attempt to extract the item.		  // To be more safe, you should only enable this feature if the item's file name ends with		  // ".bin", since this is usually the case for MB encoded files of this problematic kind.		  		  me.supportMB1 = enabled		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub EnableFileLocking(enabled as Boolean)		  // Since v1.1 of this Zip package, items marked as "protected" in the archive		  // will not be locked any more by default when extracted.		  // To have such items locked at extraction, call this function with "true" as		  // the "enabled" parameter.		  		  me.lockFiles = enabled		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function Name() As String		  // returns the file name without any path in front of it		  		  return me.path(Ubound(me.path))		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ExternalFileAttributes() As Integer		  // retrieves "external file attributes", a 4 byte field		  //		  // Is supposed to return the unix permissions in the upper 8 bits if the "OS made by" value is 3		  //		  // Call SetExternalFileAttributes() to change the value.		  // Default for newly created items depends on "OSMadeBy" for the item:		  //  if 3 (unix), the file's permissions are copied, provided this code runs on a Mac or Linux machine (but not Windows),		  //  otherwise this field is set to 0.		  // However, the lowest byte (bit 0) should the value 1 to tell ZipIt 2.2.2 that the file name is UTF-8 encoded		  		  return me.header.Long(38)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub SetExternalFileAttributes(attr as Integer)		  // sets the 4-byte Attributes (Permissions) field		  //		  // Call ExternalFileAttributes() to inquire about the current value		  		  me.header.Long(38) = attr		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function ApplyUnixPermissions(f as FolderItem) As Boolean		  //		  // Updates the Unix permissions of the given file with the "external file attribute" value from the zip entry.		  //		  // Returns true only if the unix permissions could be set (i.e. it will always fail on a Windows system)		  //		  		  #if TargetMacOS		    		    dim v as Integer		    		    v = me.ExternalFileAttributes		    if v < 0 then // highest bit of 16 bit permission field is set (before right shift) -> permission appears to be valid		      return ApplyUnixPermissions(f, v)		    end		    		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Extract(destination as FolderItem, decodeMacBinary as Boolean, makeExecutable as Boolean) As Boolean		  // Stores the data of this entry in a file or creates a folder.		  // If the destination item already exists, it will be replaced, unless there's a folder<->file conflict		  //   or if the file, containing folder or volume is write protected (locked)		  // Sets the modification (but not creation) date to the information from the archive entry.		  // If the entry contains Type&Creator information, the destination file will get them assigned,		  //   otherwise T&C will be set depending on the file's extension. (Mac OS only)		  // If the entry contains an explicit Macintosh file name, the destination will receive this name		  //   if the passed destination.Name was identical to the archive entry's DOS name. (Mac OS only)		  // If the entry is stored in MacBinary format and decodeMacBinary is TRUE, it will be automatically		  //   split into its data and resource fork - on Mac OS both will be written to the destination file,		  //   on Windows only the data fork will be written, while the resource fork will be ignored.		  // If 'makeExecutable' is true, extracted files that are not marked as text files and which do not		  //   contain unix file permissions, will be made executable on Mac OS systems so that Mac OS		  //   Packages become executable (Stuffit Expander does this, too). If this parameter is false,		  //   files will be made executable only if unix permissions are included (this is how the unix		  //   command line tools "zip" and "unzip" do it). Using "false" may speed up extraction a little,		  //   that's why you have the choice here: if you know that the archive you are extracting has been		  //   created with this software (v1.2) or the cmdline "zip" tool, the correct permissions will		  //   automatically be set, then set 'makeExecutable' to "false"; but if the file may contain executable		  //   files and has been created by some other tools such as ZipIt, you might want to set this parm		  //   to true to make sure the files remain executable after extraction.		  // Returns TRUE if it was successful. FALSE might mean a bad CRC or other data errors,		  //   including a write failure due to a locked or full volume or existing and locked file		  		  dim dataFork, rsrcFork as SeqDataOutputStream, d as Date, ok as Boolean, type, crea, name as String		  dim fsref, mbHdr as MemoryBlock, bs as BinaryStream		  dim v, attr, os, res as Integer		  		  if destination = nil then		    me.errmsg = "No destination given"		    return false		  end		  		  if me.isFolder then		    if not destination.exists then		      destination.CreateAsFolder		    end		    if not destination.exists then		      me.errmsg = "Folder creation failed"		      return false		    end		    if not destination.Directory then		      me.errmsg = "Archive entry is a folder but a file exists at the destination already. Won't replace that."		      return false		    end		  else		    if destination.Directory then		      me.errmsg = "Archive entry is a file but a folder exists at the destination already. Won't replace that."		      return false		    end		  end		  		  if destination.Alias then // !TT added 17Apr2003 to avoid that we write into Alias files		    destination.Delete		    if destination.Exists then		      me.errmsg = "Destination exists as an alias file that can't be deleted"		      return false		    end		  end		  		  // create the file if it does not already exist		  if not destination.exists then		    bs = destination.CreateBinaryFile("")		    if bs = nil then		      me.errmsg = "Creating destination file failed"		      return false		    end		    bs.Close		  end		  		  if destination.Locked then		    me.errmsg = "Destination file is write protected"		    return false		  end		  		  // create a data fork writer		  dataFork = new FileWriter(destination)		  		  // create a rsrc fork writer in case we're on the Mac and it shall be extracted from the entry data		  #if TargetMacOS		    if decodeMacBinary then		      rsrcFork = new RsrcForkWriter(destination)		    end		  #endif		  		  // perform the extraction		  ok = z_unzip(dataFork, rsrcFork, decodeMacBinary, me.isFolder, mbHdr)		  		  if not ok then		    destination.Delete		  else		    		    // update modification time/date		    d = me.Time()		    if d <> nil then		      destination.CreationDate = d // !TT 21Jun05 added to prevent Norton and other tools from complaining about creation > modification date		      destination.ModificationDate = d		    end		    		    #if TargetMacOS		      // update Type and Creator		      if mbHdr <> nil then		        // use the Type and Creator from the stored file's MacBinary header		        ApplyMacBinaryInformation(destination, mbHdr)		      elseif me.extra <> nil and me.extra.GetTypeCreatorName(type, crea, name) then		        // use the information from the archive entry's Extra Field		        destination.MacType = type		        destination.MacCreator = crea		        if name <> "" then		          z_adjustMacFilename name, 0, destination		        end		      elseif z_icMapFilename(destination.name,type, crea) then		        // use the Type and Creator that the OS service "Internet Config" recommends for a file with this extension		        destination.MacType = type		        destination.MacCreator = crea		      end		      		      // update Unix permissions		      attr = me.ExternalFileAttributes		      os = me.OSMadeBy		      if attr < 0 and (os = 0 or os = 3 or os = 7) then // os: 0 -> PKZip, 3 -> info-zip, 7 -> ZipIt		        // attributes field appears to contain unix permissions		        if not me.ApplyUnixPermissions(destination, attr) then		          // note: we ignore the error here, because it's only minor if this should fail (which would be the case when running on Windows, for example)		        end		      elseif makeExecutable and not me.isFolder and not me.IsTextFile() then		        // set the "X" attribute on all binary files to make apps runnable that are Mac OS Packages		        fsref = me.d.makeFSRef(destination)		        if fsref <> nil then		          if me.d.updateUnixPermissions(fsref, &HFFFFFFFF, &H149) <> 0 then		            // note: we ignore the error here, because it's only minor if this should fail (which would be the case when running on Windows, for example)		          end		        end		      end		      		    #endif		    		  end		  		  return ok		  		Exception err as RuntimeException		  me.errmsg = "Internal error (exception)"		  return false		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ApplyUnixPermissions(f as FolderItem, permShl16 as Integer) As Boolean		  //		  // Updates the Unix permissions of the given file with the given value, which must be the unix permissions shifted left by 16 bits		  //		  // Returns true only if the unix permissions could be set (i.e. it will always fail on a Windows system)		  //		  		  #if TargetMacOS		    		    dim fsref as MemoryBlock		    dim res as Integer		    		    fsref = me.d.makeFSRef(f)		    if fsref <> nil then		      res = me.d.updateUnixPermissions(fsref, 0, me.d.shiftRight16(permShl16))		      if res = 0 then		        return true		      end		    end		    		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub z_setAppleDoubleEntry(ze as ZipEntry)		  me.appleDoubleEntry = ze		  ze.thisIsTheAppleDoubleEntry = true		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function z_unzipMBHdr(isAppleDouble as Boolean, data as String, ByRef mbHdr as MemoryBlock, ByRef rsrcForkStart as Integer) As Boolean		  dim mb as MemoryBlock		  dim dummyInt, i as Integer		  		  mb = NewMemoryBlock(128)		  if mb = nil then		    raise new OutOfMemoryException		  end		  mb.LittleEndian = false		  if isAppleDouble then		    mbHdr = mb		    mb = NewMemoryBlock(LenB(data))		    if mb = nil then		      raise new OutOfMemoryException		    end		    mb.LittleEndian = false // !TT added 18Mac07 as I believe this is necessary (not tested, though)		    mb.StringValue(0,mb.Size) = data		    if mb.Long(0) <> &h00051607 or mb.Long(4) <> &h00020000 or mb.Short(24) <> 2 or mb.Long(26) <> 9 or mb.Long(34) < &h20  or mb.Long(38) <> 2 then		      // this is not a valid AppleDouble header, at least not one we expect here (as created by ditto)		      me.errmsg = "Invalid or unsupported AppleDouble header"		      return false		    end		    i = mb.Long(30) // offset into Finder Info		    mbHdr.StringValue(65,16) = mb.StringValue(i,16) // copy FInfo		    mbHdr.Byte(106) = mb.Byte(i+16+8) // copy FXInfo.fdScript		    mbHdr.Byte(107) = mb.Byte(i+16+9) // copy FXInfo.fdXFlags		    mbHdr.Byte(101) = mbHdr.Byte(74)		    mbHdr.Byte(74) = 0		    if me.extra.GetUnixTimes(dummyInt, i) then		      i = i+UnixToMacTimeOffset+UTCOffsetInMinutes*60 //convert Unix UTC into Mac local time		      mbHdr.Long(91) = i // creation date		      mbHdr.Long(95) = i // modification date		    end		    rsrcForkStart = mb.Long(42)		    mbHdr.Long(87) = mb.Long(46)		  else		    mb.StringValue(0,128) = data		    // check whether the MB header is valid		    if z_MBHdrLevel(mb) > 0 then		      mbHdr = mb		      rsrcForkStart = BitwiseAnd(255 + mb.Long(83), &HFFFFFF80)		    else		      // does not appear to be a MB header -> just write this out as a normal part of the file		    end		  end		  return true		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function UTCOffsetInMinutes() As Integer		  // Returns the offset of the current time to UTC (GMT) in minutes.		  // supports Mac OS, Windows and Linux		  //		  // Note that the offset is not always an even multiple of 60,  but		  // there are also half hour offsets, even one 5:45h offset		  		  // This 5th version by Thomas Tempelmann (rb@tempel.org) on 21 Apr 2006		  //		  // Using code from various authors found on the RB NUG mailing list		  //		  // Latest version can be found here: http://www.tempel.org/rb/#gmt		  		  dim offset as integer		  		  #if TargetLinux or TargetMachO then		    #if TargetMachO then		      declare function localtime_r lib "/usr/lib/libc.dylib" (time_in as Ptr, time_out as Ptr) as Ptr		      declare function time lib "/usr/lib/libc.dylib" (tloc_ptr as Integer) as Integer		    #else		      soft declare function localtime_r lib "LibC" (time_in as Ptr, time_out as Ptr) as Ptr		      //declare function localtime_r lib "/usr/lib/libc.so" (time_in as Ptr, time_out as Ptr) as Ptr		      soft declare function time lib "LibC" (tloc_ptr as Integer) as Integer		      //declare function time lib "/usr/lib/libc.so" (tloc_ptr as Integer) as Integer		    #endif		    dim time_in, time_out as MemoryBlock		    time_in =  new MemoryBlock(4)		    time_out =  new MemoryBlock(44) // we assume that "int" is 4 byte on any supported Linux system		    time_in.Long(0) = time (0) // Bugfix TT 21Apr06: need to pass current local time to get summer time offsets correctly		    call localtime_r (time_in, time_out)		    offset = time_out.Long (36) \ 60		  #elseif TargetMacOS then		    #if TargetMachO		      Declare Sub ReadLocation lib "Carbon" (location As ptr)		    #else		      #if TargetCarbon		        Declare Sub ReadLocation lib "CarbonLib" (location As ptr)		      #else		        Declare Sub ReadLocation lib "InterfaceLib" (location As ptr) Inline68k("205F203C000C00E4A051")		      #endif		    #endif		    dim info as memoryBlock		    dim byteOffset as integer		    info = NewMemoryBlock(12)		    ReadLocation info		    if info.LittleEndian then		      byteOffset = 8		    else		      byteOffset = 11		    end		    offset = info.short(9) * 256 + info.byte(byteOffset)		    offset = offset \ 60		  #elseif TargetWin32 then		    Declare Function GetTimeZoneInformation Lib "Kernel32" ( tzInfoPointer as Ptr ) as Integer		    // returns one of		    // TIME_ZONE_ID_UNKNOWN 0		    //      -- Note: e.g. New Delhi (GMT+5:30) and Newfoundland (-3:30) return this value 0		    // TIME_ZONE_ID_STANDARD 1		    // TIME_ZONE_ID_DAYLIGHT 2		    dim info as memoryBlock		    dim result, bias, dayLightbias as integer		    info = new MemoryBlock(172)		    result = GetTimeZoneInformation(info)		    bias = info.Long(0)		    // note about bias: the original code I found in the NUG archives used Long(84) and switched to Long(0)		    // only for result=1 and result=2, but my tests found that Long(0) is also the right value for result=0		    if result = 2 then		      daylightBias = info.long(168)		    end if		    offset = - (bias + dayLightbias)		  #else		    this target is not supported yet - see if there's a new version at <www.tempel.org/rb/>		  #endif		  		  return offset		End Function	#tag EndMethod	#tag Note, Name = About				See the notes in the class "ZipArchive" for more information	#tag EndNote	#tag Note, Name = Important				----------------------------------		Important note about adding Set... functions here		----------------------------------		  		We must not provide methods that allow the change of any ZipEntry		  properties other than the comment (comments are stored only in the dir)		  here, because altering any other properties would only be stored in		  the Central Directory structure, but not in the Local File Header,		  causing header mismatches.				So, if one wants to alter the name or the Extra Field of an item in the		  archive, the entire archived file needs to be rewritten (appended)		  with the current implemention of these classes. To overcome this		  limitation, one would have to move any data behind the modified		  entry, which can be quite inefficient with larger archives. Instead,		  the way to go is to Remove the original entry, then generate a new		  one and copy the compressed data over. The only exception is when		  the replacement will be the same size or smaller than the original.		  In case it's smaller, ZipArchive.Compact should be called afterwards.	#tag EndNote	#tag Property, Flags = &h1		Protected sysEncComment As String	#tag EndProperty	#tag Property, Flags = &h1		Protected zipEncName As String	#tag EndProperty	#tag Property, Flags = &h1		Protected header As MemoryBlock	#tag EndProperty	#tag Property, Flags = &h1		Protected extra As ZipExtraField	#tag EndProperty	#tag Property, Flags = &h1		Protected zlib_prefix As MemoryBlock	#tag EndProperty	#tag Property, Flags = &h1		Protected errmsg As String	#tag EndProperty	#tag Property, Flags = &h1		Protected path(-1) As String	#tag EndProperty	#tag Property, Flags = &h1		Protected isFolder As Boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected maxIntPlus1 As Double	#tag EndProperty	#tag Property, Flags = &h1		Protected d As ZipArchiveData	#tag EndProperty	#tag Property, Flags = &h1		Protected sysEncName As String	#tag EndProperty	#tag Property, Flags = &h1		Protected zipEncComment As String	#tag EndProperty	#tag Property, Flags = &h1		Protected supportMB1 As Boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected lockFiles As Boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected appleDoubleEntry As ZipEntry	#tag EndProperty	#tag Property, Flags = &h0		z_hasDittoName As Boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected thisIsTheAppleDoubleEntry As Boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected runningOnClassic As Boolean	#tag EndProperty	#tag Constant, Name = UnixToMacTimeOffset, Type = Integer, Dynamic = False, Default = \"2082844800", Scope = Public	#tag EndConstant	#tag ViewBehavior		#tag ViewProperty			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Group="Behavior"			InitialValue="0"			Type="Boolean"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass